<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
      <title>Introduction to the Interaction Service | Discord.Net Documentation </title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta name="title" content="Introduction to the Interaction Service | Discord.Net Documentation ">
      
      
      <link rel="icon" href="../../favicon.png">
      <link rel="stylesheet" href="../../public/docfx.min.css">
      <link rel="stylesheet" href="../../public/main.css">
      <meta name="docfx:navrel" content="../../toc.html">
      <meta name="docfx:tocrel" content="../toc.html">
      
      <meta name="docfx:rel" content="../../">
      
      
      <meta name="docfx:docurl" content="https://github.com/discord-net/Discord.Net/blob/dev/docs/guides/int_framework/intro.md/#L1">
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
      <meta name="loc:downloadPdf" content="Download PDF">

      <script type="module" src="./../../public/docfx.min.js"></script>

      <script>
        const theme = localStorage.getItem('theme') || 'auto'
        document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
      </script>

  <meta property="og:description" content="The Interaction Service provides an attribute based framework for creating Discord Interaction handlers."><meta property="og:title" content="Introduction to the Interaction Service | Discord.Net Documentation "><meta property="og:site_name" content="Discord.Net Docs"><meta name="theme-color" content="#995EA7"><meta property="og:image" content="https://raw.githubusercontent.com/Discord-Net/Discord.Net/dev/docs/marketing/logo/PackageLogo.png"></head>

  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../../index.html">
            <img id="logo" class="svg" src="../../marketing/logo/SVG/Logomark Purple.svg" alt="Discord.Net">
            Discord.Net
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
              <form class="search" role="search" id="search">
                <i class="bi bi-search"></i>
                <input class="form-control" id="search-query" type="search" disabled placeholder="Search" autocomplete="off" aria-label="Search">
              </form>
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">
      <div class="toc-offcanvas">
        <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
          <div class="offcanvas-header">
            <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
          </div>
          <div class="offcanvas-body">
            <nav class="toc" id="toc"></nav>
          </div>
        </div>
      </div>

      <div class="content">
        <div class="actionbar">
          <button class="btn btn-lg border-0 d-md-none" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
            <i class="bi bi-list"></i>
          </button>

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="Guides.IntFw.Intro">
<h1 id="getting-started">Getting Started</h1>

<p>The Interaction Service provides an attribute based framework for creating Discord Interaction handlers.</p>
<p>To start using the Interaction Service, you need to create a service instance.
Optionally you can provide the <a class="xref" href="../../api/Discord.Interactions.InteractionService.html">InteractionService</a> constructor with a
<a class="xref" href="../../api/Discord.Interactions.InteractionServiceConfig.html">InteractionServiceConfig</a> to change the services behaviour to suit your needs.</p>
<pre><code class="lang-csharp">...
// _client here is DiscordSocketClient.
// A different approach to passing in a restclient is also possible.
var _interactionService = new InteractionService(_client.Rest);

...
</code></pre>
<h2 id="modules">Modules</h2>
<p>Attribute based Interaction handlers must be defined within a command module class.
Command modules are responsible for executing the Interaction handlers and providing them with the necessary execution info and helper functions.</p>
<p>Command modules are transient objects.
A new module instance is created before a command execution starts then it will be disposed right after the method returns.</p>
<p>Every module class must:</p>
<ul>
<li>Be public</li>
<li>Inherit from <a class="xref" href="../../api/Discord.Interactions.InteractionModuleBase.html">InteractionModuleBase</a></li>
</ul>
<p>Optionally you can override the included :</p>
<ul>
<li>OnModuleBuilding (executed after the module is built)</li>
<li>BeforeExecute (executed before a command execution starts)</li>
<li>AfterExecute (executed after a command execution concludes)</li>
</ul>
<p>methods to configure the modules behaviour.</p>
<p>Every command module exposes a set of helper methods, namely:</p>
<ul>
<li><code>RespondAsync()</code> =&gt; Respond to the interaction</li>
<li><code>FollowupAsync()</code> =&gt; Create a followup message for an interaction</li>
<li><code>ReplyAsync()</code> =&gt; Send a message to the origin channel of the interaction</li>
<li><code>DeleteOriginalResponseAsync()</code> =&gt; Delete the original interaction response</li>
</ul>
<h2 id="commands">Commands</h2>
<p>Valid <strong>Interaction Commands</strong> must comply with the following requirements:</p>
<table>
<thead>
<tr>
<th></th>
<th>return type</th>
<th>max parameter count</th>
<th>allowed parameter types</th>
<th>attribute</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="#slash-commands">Slash Command</a></td>
<td><code>Task</code>/<code>Task&lt;RuntimeResult&gt;</code></td>
<td>25</td>
<td>any*</td>
<td><code>[SlashCommand]</code></td>
</tr>
<tr>
<td><a href="#user-commands">User Command</a></td>
<td><code>Task</code>/<code>Task&lt;RuntimeResult&gt;</code></td>
<td>1</td>
<td>Implementations of <code>IUser</code></td>
<td><code>[UserCommand]</code></td>
</tr>
<tr>
<td><a href="#message-commands">Message Command</a></td>
<td><code>Task</code>/<code>Task&lt;RuntimeResult&gt;</code></td>
<td>1</td>
<td>Implementations of <code>IMessage</code></td>
<td><code>[MessageCommand]</code></td>
</tr>
<tr>
<td><a href="#component-interaction-commands">Component Interaction Command</a></td>
<td><code>Task</code>/<code>Task&lt;RuntimeResult&gt;</code></td>
<td>inf</td>
<td><code>string</code> or <code>string[]</code></td>
<td><code>[ComponentInteraction]</code></td>
</tr>
<tr>
<td><a href="#autocomplete-commands">Autocomplete Command</a></td>
<td><code>Task</code>/<code>Task&lt;RuntimeResult&gt;</code></td>
<td>-</td>
<td>-</td>
<td><code>[AutocompleteCommand]</code></td>
</tr>
</tbody>
</table>
<div class="NOTE">
<h5>Note</h5>
<p>A <code>TypeConverter</code> that is capable of parsing type in question must be registered to the <a class="xref" href="../../api/Discord.Interactions.InteractionService.html">InteractionService</a> instance.
You should avoid using long running code in your command module.
Depending on your setup, long running code may block the Gateway thread of your bot, interrupting its connection to Discord.</p>
</div>
<h2 id="slash-commands">Slash Commands</h2>
<p>Slash Commands are created using the <a class="xref" href="../../api/Discord.Interactions.SlashCommandAttribute.html">SlashCommandAttribute</a>.
Every Slash Command must declare a name and a description.
You can check Discords <strong>Application Command Naming Guidelines</strong>
<a href="https://discord.com/developers/docs/interactions/application-commands#application-command-object-application-command-naming">here</a>.</p>
<pre><code class="lang-csharp" name="Slash Command">[SlashCommand(&quot;echo&quot;, &quot;Echo an input&quot;)]
public async Task Echo(string input)
{
    await RespondAsync(input);
}
</code></pre><h3 id="parameters">Parameters</h3>
<p>Slash Commands can have up to 25 method parameters. You must name your parameters in accordance with
<a href="https://discord.com/developers/docs/interactions/application-commands#application-command-object-application-command-naming">Discords Naming Guidelines</a>.
<a class="xref" href="../../api/Discord.Interactions.InteractionService.html">InteractionService</a> also features a pascal casing seperator for formatting parameter names with
pascal casing into Discord compliant parameter names('parameterName' =&gt; 'parameter-name').
By default, your methods can feature the following parameter types:</p>
<ul>
<li>Implementations of <a class="xref" href="../../api/Discord.IUser.html">IUser</a></li>
<li>Implementations of <a class="xref" href="../../api/Discord.IChannel.html">IChannel</a></li>
<li>Implementations of <a class="xref" href="../../api/Discord.IRole.html">IRole</a></li>
<li>Implementations of <a class="xref" href="../../api/Discord.IMentionable.html">IMentionable</a></li>
<li>Implementations of <a class="xref" href="../../api/Discord.IAttachment.html">IAttachment</a></li>
<li><code>string</code></li>
<li><code>float</code>, <code>double</code>, <code>decimal</code></li>
<li><code>bool</code></li>
<li><code>char</code></li>
<li><code>sbyte</code>, <code>byte</code></li>
<li><code>int16</code>, <code>int32</code>, <code>int64</code></li>
<li><code>uint16</code>, <code>uint32</code>, <code>uint64</code></li>
<li><code>enum</code></li>
<li><code>DateTime</code></li>
<li><code>TimeSpan</code></li>
</ul>
<div class="NOTE">
<h5>Note</h5>
<p>Enum values are registered as multiple choice options and are enforced by Discord. Use the <code>[Hide]</code> attribute on enum values to prevent them from getting registered.</p>
</div>
<hr>
<p><strong>You can use more specialized implementations of <a class="xref" href="../../api/Discord.IChannel.html">IChannel</a> to restrict the allowed channel types for a channel type option.</strong></p>
<table>
<thead>
<tr>
<th>interface</th>
<th>Channel Type</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>IStageChannel</code></td>
<td>Stage Channels</td>
</tr>
<tr>
<td><code>IVoiceChannel</code></td>
<td>Voice Channels</td>
</tr>
<tr>
<td><code>IDMChannel</code></td>
<td>DM Channels</td>
</tr>
<tr>
<td><code>IGroupChannel</code></td>
<td>Group Channels</td>
</tr>
<tr>
<td><code>ICategoryChannel</code></td>
<td>Category Channels</td>
</tr>
<tr>
<td><code>INewsChannel</code></td>
<td>News Channels</td>
</tr>
<tr>
<td><code>IThreadChannel</code></td>
<td>Public, Private, News Threads</td>
</tr>
<tr>
<td><code>ITextChannel</code></td>
<td>Text Channels</td>
</tr>
</tbody>
</table>
<hr>
<h4 id="optional-parameters">Optional Parameters</h4>
<p>Parameters with default values (ie. <code>int count = 0</code>) will be displayed as optional parameters on Discord Client.</p>
<h4 id="parameter-summary">Parameter Summary</h4>
<p>By using the <a class="xref" href="../../api/Discord.Interactions.SummaryAttribute.html">SummaryAttribute</a> you can customize the displayed name and description of a parameter</p>
<pre><code class="lang-csharp" name="Summary Attribute">[Summary(description: &quot;this is a parameter description&quot;)] string input
</code></pre><h4 id="parameter-choices">Parameter Choices</h4>
<p><a class="xref" href="../../api/Discord.Interactions.ChoiceAttribute.html">ChoiceAttribute</a> can be used to add choices to a parameter.</p>
<pre><code class="lang-csharp" name="Choice Attribute">[SlashCommand(&quot;blep&quot;, &quot;Send a random adorable animal photo&quot;)]
public async Task Blep([Choice(&quot;Dog&quot;, &quot;dog&quot;), Choice(&quot;Cat&quot;, &quot;cat&quot;), Choice(&quot;Guinea pig&quot;, &quot;GuineaPig&quot;)] string animal)
{
    ...
}

// In most cases, you can use an enum to replace the separate choice attributes in a command.

public enum Animal
{
    Cat,
    Dog,
    // You can also use the ChoiceDisplay attribute to change how they appear in the choice menu.
    [ChoiceDisplay(&quot;Guinea pig&quot;)]
    GuineaPig
}

[SlashCommand(&quot;blep&quot;, &quot;Send a random adorable animal photo&quot;)]
public async Task Blep(Animal animal)
{
    ...
}
```
</code></pre>
<p>This Slash Command will be displayed exactly the same as the previous example.</p>
<h4 id="channel-types">Channel Types</h4>
<p>Channel types for an <a class="xref" href="../../api/Discord.IChannel.html">IChannel</a> parameter can also be restricted using the <a class="xref" href="../../api/Discord.Interactions.ChannelTypesAttribute.html">ChannelTypesAttribute</a>.</p>
<pre><code class="lang-csharp" name="Channel Attribute">[SlashCommand(&quot;name&quot;, &quot;Description&quot;)]
public async Task Command([ChannelTypes(ChannelType.Stage, ChannelType.Text)] IChannel channel)
{
    ...
}
</code></pre>
<p>In this case, user can only input Stage Channels and Text Channels to this parameter.</p>
<h4 id="minmax-value">Min/Max Value</h4>
<p>You can specify the permitted max/min value for a number type parameter using the <a class="xref" href="../../api/Discord.Interactions.MaxValueAttribute.html">MaxValueAttribute</a> and <a class="xref" href="../../api/Discord.Interactions.MinValueAttribute.html">MinValueAttribute</a>.</p>
<h4 id="complex-parameters">Complex Parameters</h4>
<p>This allows users to create slash command options using an object's constructor allowing complex objects to be created which cannot be infered from only one input value.
Constructor methods support every attribute type that can be used with the regular slash commands ([Autocomplete], [Summary] etc. ).
Preferred constructor of a Type can be specified either by passing a <code>Type[]</code> to the <code>[ComplexParameterAttribute]</code> or tagging a type constructor with the <code>[ComplexParameterCtorAttribute]</code>. If nothing is specified, the InteractionService defaults to the only public constructor of the type.
TypeConverter pattern is used to parse the constructor methods objects.</p>
<pre><code class="lang-csharp" name="Complex Parameter">public class Vector3
{
    public int X {get;}
    public int Y {get;}
    public int Z {get;}

    public Vector3()
    {
        X = 0;
        Y = 0;
        Z = 0;
    }

    [ComplexParameterCtor]
    public Vector3(int x, int y, int z)
    {
        X = x;
        Y = y;
        Z = z;
    }
}

// Both of the commands below are displayed to the users identically.

// With complex parameter
[SlashCommand(&quot;create-vector&quot;, &quot;Create a 3D vector.&quot;)]
public async Task CreateVector([ComplexParameter]Vector3 vector3)
{
    ...
}

// Without complex parameter
[SlashCommand(&quot;create-vector&quot;, &quot;Create a 3D vector.&quot;)]
public async Task CreateVector(int x, int y, int z)
{
    ...
}
</code></pre>
<p>Interaction service complex parameter constructors are prioritized in the following order:</p>
<ol>
<li>Constructor matching the signature provided in the <code>[ComplexParameter(Type[])]</code> overload.</li>
<li>Constuctor tagged with <code>[ComplexParameterCtor]</code>.</li>
<li>Type's only public constuctor.</li>
</ol>
<h4 id="dm-permissions">DM Permissions</h4>
<div class="WARNING">
<h5>Warning</h5>
<p><a class="xref" href="../../api/Discord.Interactions.EnabledInDmAttribute.html">EnabledInDmAttribute</a> is being deprecated in favor of <a class="xref" href="../../api/Discord.Interactions.CommandContextTypeAttribute.html">CommandContextType</a> attribute.</p>
</div>
<p>You can use the <a class="xref" href="../../api/Discord.Interactions.EnabledInDmAttribute.html">EnabledInDmAttribute</a> to configure whether a globally-scoped top level command should be enabled in Dms or not. Only works on top level commands.</p>
<h4 id="default-member-permissions">Default Member Permissions</h4>
<p><a class="xref" href="../../api/Discord.Interactions.DefaultMemberPermissionsAttribute.html">DefaultMemberPermissionsAttribute</a> can be used when creating a command to set the permissions a user must have to use the command. Permission overwrites can be configured from the Integrations page of Guild Settings. <a class="xref" href="../../api/Discord.Interactions.DefaultMemberPermissionsAttribute.html">DefaultMemberPermissionsAttribute</a> cumulatively propagates down the class hierarchy until it reaches a top level command. This attribute can be only used on top level commands and will not work on commands that are nested in command groups.</p>
<h2 id="user-commands">User Commands</h2>
<p>A valid User Command must have the following structure:</p>
<pre><code class="lang-csharp" name="User Command">[UserCommand(&quot;Say Hello&quot;)]
public async Task SayHello(IUser user)
{
    ...
}
</code></pre>
<div class="WARNING">
<h5>Warning</h5>
<p>User commands can only have one parameter and its type must be an implementation of <a class="xref" href="../../api/Discord.IUser.html">IUser</a>.</p>
</div>
<h2 id="message-commands">Message Commands</h2>
<p>A valid Message Command must have the following structure:</p>
<pre><code class="lang-csharp" name="Message Command">[MessageCommand(&quot;Bookmark&quot;)]
public async Task Bookmark(IMessage msg)
{
    ...
}
</code></pre>
<div class="WARNING">
<h5>Warning</h5>
<p>Message commands can only have one parameter and its type must be an implementation of <a class="xref" href="../../api/Discord.IMessage.html">IMessage</a>.</p>
</div>
<h2 id="component-interaction-commands">Component Interaction Commands</h2>
<p>Component Interaction Commands are used to handle interactions that originate from <strong>Discord Message Component</strong>s.
This pattern is particularly useful if you will be reusing a set a <strong>Custom ID</strong>s.</p>
<p>Component Interaction Commands support wild card matching,
by default <code>*</code> character can be used to create a wild card pattern.
Interaction Service will use lazy matching to capture the words corresponding to the wild card character.
And the captured words will be passed on to the command method in the same order they were captured.</p>
<pre><code class="lang-csharp" name="Button">[ComponentInteraction(&quot;player:*,*&quot;)]
public async Task Play(string op, string name)
{
    ...
}
</code></pre>
<p>You may use as many wild card characters as you want.</p>
<div class="NOTE">
<h5>Note</h5>
<p>If Interaction Service receives a component interaction with <strong>player:play,rickroll</strong> custom id,
<code>op</code> will be <em>play</em> and <code>name</code> will be <em>rickroll</em></p>
</div>
<h2 id="select-menus">Select Menus</h2>
<p>Unlike button interactions, select menu interactions also contain the values of the selected menu items.
In this case, you should structure your method to accept a string array.</p>
<div class="NOTE">
<h5>Note</h5>
<p>Use arrays of <code>IUser</code>, <code>IChannel</code>, <code>IRole</code>, <code>IMentionable</code> or their implementations to get data from a select menu with respective type.</p>
</div>
<pre><code class="lang-csharp" name="Dropdown">[ComponentInteraction(&quot;role_selection&quot;)]
public async Task RoleSelection(string[] selectedRoles)
{
    ...
}

[ComponentInteraction(&quot;role_selection_*&quot;)]
public async Task RoleSelection(string id, string[] selectedRoles)
{
    ...
}
</code></pre>
<div class="NOTE">
<h5>Note</h5>
<p>Wildcards may also be used to match a select menu ID,
though keep in mind that the array containing the select menu values should be the last parameter.</p>
</div>
<h2 id="autocomplete-commands">Autocomplete Commands</h2>
<p>Autocomplete commands must be parameterless methods. A valid Autocomplete command must have the following structure:</p>
<pre><code class="lang-csharp" name="Autocomplete Command">[AutocompleteCommand(&quot;parameter_name&quot;, &quot;command_name&quot;)]
public async Task Autocomplete()
{
    string userInput = (Context.Interaction as SocketAutocompleteInteraction).Data.Current.Value.ToString();

    IEnumerable&lt;AutocompleteResult&gt; results = new[]
    {
        new AutocompleteResult(&quot;foo&quot;, &quot;foo_value&quot;),
        new AutocompleteResult(&quot;bar&quot;, &quot;bar_value&quot;),
        new AutocompleteResult(&quot;baz&quot;, &quot;baz_value&quot;),
    }.Where(x =&gt; x.Name.StartsWith(userInput, StringComparison.InvariantCultureIgnoreCase)); // only send suggestions that starts with user's input; use case insensitive matching


    // max - 25 suggestions at a time
    await (Context.Interaction as SocketAutocompleteInteraction).RespondAsync(results.Take(25));
}

// you need to add `Autocomplete` attribute before parameter to add autocompletion to it
[SlashCommand(&quot;command_name&quot;, &quot;command_description&quot;)]
public async Task ExampleCommand([Summary(&quot;parameter_name&quot;), Autocomplete] string parameterWithAutocompletion)
    =&gt; await RespondAsync($&quot;Your choice: {parameterWithAutocompletion}&quot;);
</code></pre>
<p>Alternatively, you can use the <a class="xref" href="autocompletion.html">AutocompleteHandlers</a> to simplify this workflow.</p>
<h2 id="modals">Modals</h2>
<p>Modal commands last parameter must be an implementation of <code>IModal</code>.
A Modal implementation would look like this:</p>
<pre><code class="lang-csharp" name="Modal Command">// Registers a command that will respond with a modal.
[SlashCommand(&quot;food&quot;, &quot;Tell us about your favorite food.&quot;)]
public async Task Command()
    =&gt; await Context.Interaction.RespondWithModalAsync&lt;FoodModal&gt;(&quot;food_menu&quot;);

// Defines the modal that will be sent.
public class FoodModal : IModal
{
    public string Title =&gt; &quot;Fav Food&quot;;
    // Strings with the ModalTextInput attribute will automatically become components.
    [InputLabel(&quot;What??&quot;)]
    [ModalTextInput(&quot;food_name&quot;, placeholder: &quot;Pizza&quot;, maxLength: 20)]
    public string Food { get; set; }

    // Additional paremeters can be specified to further customize the input.    
    // Parameters can be optional
    [RequiredInput(false)]
    [InputLabel(&quot;Why??&quot;)]
    [ModalTextInput(&quot;food_reason&quot;, TextInputStyle.Paragraph, &quot;Kuz it's tasty&quot;, maxLength: 500)]
    public string Reason { get; set; }
}

// Responds to the modal.
[ModalInteraction(&quot;food_menu&quot;)]
public async Task ModalResponse(FoodModal modal)
{
    // Check if &quot;Why??&quot; field is populated
    string reason = string.IsNullOrWhiteSpace(modal.Reason)
        ? &quot;.&quot;
        : $&quot; because {modal.Reason}&quot;;

    // Build the message to send.
    string message = &quot;hey @everyone, I just learned &quot; +
        $&quot;{Context.User.Mention}'s favorite food is &quot; +
        $&quot;{modal.Food}{reason}&quot;;

    // Specify the AllowedMentions so we don't actually ping everyone.
    AllowedMentions mentions = new();
    mentions.AllowedTypes = AllowedMentionTypes.Users;

    // Respond to the modal.
    await RespondAsync(message, allowedMentions: mentions, ephemeral: true);
}
</code></pre>
<div class="NOTE">
<h5>Note</h5>
<p>If you are using Modals in the interaction service it is <strong>highly
recommended</strong> that you enable <code>PreCompiledLambdas</code> in your config
to prevent performance issues.</p>
</div>
<h2 id="interaction-context">Interaction Context</h2>
<p>Every command module provides its commands with an execution context.
This context property includes general information about the underlying interaction that triggered the command execution.
The base command context.</p>
<p>You can design your modules to work with different implementation types of <a class="xref" href="../../api/Discord.IInteractionContext.html">IInteractionContext</a>.
To achieve this, make sure your module classes inherit from the generic variant of the <a class="xref" href="../../api/Discord.Interactions.InteractionModuleBase.html">InteractionModuleBase</a>.</p>
<div class="NOTE">
<h5>Note</h5>
<p>Context type must be consistent throughout the project, or you will run into issues during runtime.</p>
</div>
<p>The <a class="xref" href="../../api/Discord.Interactions.InteractionService.html">InteractionService</a> ships with 4 different kinds of <a class="xref" href="../../api/Discord.Interactions.InteractionContext.html">InteractionContext</a>:</p>
<ol>
<li><a class="xref" href="../../api/Discord.Interactions.InteractionContext.html">InteractionContext</a>: A bare-bones execution context consisting of only implementation neutral interfaces</li>
<li><a class="xref" href="../../api/Discord.Interactions.SocketInteractionContext.html">SocketInteractionContext</a>: An execution context for use with <a class="xref" href="../../api/Discord.WebSocket.DiscordSocketClient.html">DiscordSocketClient</a>. Socket entities are exposed in this context without the need of casting them.</li>
<li><a class="xref" href="../../api/Discord.Interactions.ShardedInteractionContext.html">ShardedInteractionContext</a>: <a class="xref" href="../../api/Discord.WebSocket.DiscordShardedClient.html">DiscordShardedClient</a> variant of the <a class="xref" href="../../api/Discord.Interactions.SocketInteractionContext.html">SocketInteractionContext</a></li>
<li><a class="xref" href="../../api/Discord.Rest.RestInteractionContext.html">RestInteractionContext</a>: An execution context designed to be used with a <a class="xref" href="../../api/Discord.Rest.DiscordRestClient.html">DiscordRestClient</a> and webhook based interactions pattern</li>
</ol>
<p>You can create custom Interaction Contexts by implementing the <a class="xref" href="../../api/Discord.IInteractionContext.html">IInteractionContext</a> interface.</p>
<p>One problem with using the concrete type InteractionContexts is that you cannot access the information that is specific to different interaction types without casting. Concrete type interaction contexts are great for creating shared interaction modules but you can also use the generic variants of the built-in interaction contexts to create interaction specific interaction modules.</p>
<div class="NOTE">
<h5>Note</h5>
<p>Message component interactions have access to a special method called <code>UpdateAsync()</code> to update the body of the method the interaction originated from.
Normally this wouldn't be accessible without casting the <code>Context.Interaction</code>.</p>
</div>
<pre><code class="lang-csharp" name="Context Example">discordClient.ButtonExecuted += async (interaction) =&gt; 
{
    var ctx = new SocketInteractionContext&lt;SocketMessageComponent&gt;(discordClient, interaction);
    await _interactionService.ExecuteCommandAsync(ctx, serviceProvider);
};

public class MessageComponentModule : InteractionModuleBase&lt;SocketInteractionContext&lt;SocketMessageComponent&gt;&gt;
{
    [ComponentInteraction(&quot;custom_id&quot;)]
    public async Task Command()
    {
        await Context.Interaction.UpdateAsync(...);
    }
}
</code></pre><h2 id="loading-modules">Loading Modules</h2>
<p><a class="xref" href="../../api/Discord.Interactions.InteractionService.html">InteractionService</a> can automatically discover and load modules that inherit <a class="xref" href="../../api/Discord.Interactions.InteractionModuleBase.html">InteractionModuleBase</a> from an <code>Assembly</code>.
Call <code>InteractionService.AddModulesAsync()</code> to use this functionality.</p>
<div class="NOTE">
<h5>Note</h5>
<p>You can also manually add Interaction modules using the <code>InteractionService.AddModuleAsync()</code>
method by providing the module type you want to load.</p>
</div>
<h2 id="resolving-module-dependencies">Resolving Module Dependencies</h2>
<p>Module dependencies are resolved using the Constructor Injection and Property Injection patterns.
Meaning, the constructor parameters and public settable properties of a module will be assigned using the <code>IServiceProvider</code>.
For more information on dependency injection, read the <a class="xref" href="../dependency_injection/basics.html">DependencyInjection</a> guides.</p>
<div class="NOTE">
<h5>Note</h5>
<p>On every command execution, if the 'AutoServiceScopes' option is enabled in the config , module dependencies are resolved using a new service scope which allows you to utilize scoped service instances, just like in Asp.Net.
Including the precondition checks, every module method is executed using the same service scope and service scopes are disposed right after the <code>AfterExecute</code> method returns. This doesn't apply to methods other than <code>ExecuteAsync()</code>.</p>
</div>
<h2 id="module-groups">Module Groups</h2>
<p>Module groups allow you to create sub-commands and sub-commands groups.
By nesting commands inside a module that is tagged with <a class="xref" href="../../api/Discord.Interactions.GroupAttribute.html">GroupAttribute</a> you can create prefixed commands.</p>
<div class="WARNING">
<h5>Warning</h5>
<p>Although creating nested module structures are allowed,
you are not permitted to use more than 2 <a class="xref" href="../../api/Discord.Interactions.GroupAttribute.html">GroupAttribute</a>'s in module hierarchy.</p>
</div>
<div class="NOTE">
<h5>Note</h5>
<p>To not use the command group's name as a prefix for component or modal interaction's custom id set <code>ignoreGroupNames</code> parameter to <code>true</code> in classes with <a class="xref" href="../../api/Discord.Interactions.GroupAttribute.html">GroupAttribute</a></p>
<p>However, you have to be careful to prevent overlapping ids of buttons and modals.</p>
</div>
<pre><code class="lang-csharp" name="Command Group Example">// You can put commands in groups
[Group(&quot;group-name&quot;, &quot;Group description&quot;)]
public class CommandGroupModule : InteractionModuleBase&lt;SocketInteractionContext&gt;
{
    // This command will look like
    // group-name ping
    [SlashCommand(&quot;ping&quot;, &quot;Get a pong&quot;)]
    public async Task PongSubcommand()
        =&gt; await RespondAsync(&quot;Pong!&quot;);
    
    // And even in sub-command groups
    [Group(&quot;subcommand-group-name&quot;, &quot;Subcommand group description&quot;)]
    public class SubСommandGroupModule : InteractionModuleBase&lt;SocketInteractionContext&gt;
    {
        // This command will look like
        // group-name subcommand-group-name echo
        [SlashCommand(&quot;echo&quot;, &quot;Echo an input&quot;)]
        public async Task EchoSubcommand(string input)
            =&gt; await RespondAsync(input, components: new ComponentBuilder().WithButton(&quot;Echo&quot;, $&quot;echoButton_{input}&quot;).Build());

        // Component interaction with ignoreGroupNames set to true
        [ComponentInteraction(&quot;echoButton_*&quot;, true)]
        public async Task EchoButton(string input)
            =&gt; await RespondAsync(input);  
    }
}
</code></pre><h2 id="executing-commands">Executing Commands</h2>
<p>Any of the following socket events can be used to execute commands:</p>
<ul>
<li><a class="xref" href="../../api/Discord.WebSocket.BaseSocketClient.html">InteractionCreated</a></li>
<li><a class="xref" href="../../api/Discord.WebSocket.BaseSocketClient.html">ButtonExecuted</a></li>
<li><a class="xref" href="../../api/Discord.WebSocket.BaseSocketClient.html">SelectMenuExecuted</a></li>
<li><a class="xref" href="../../api/Discord.WebSocket.BaseSocketClient.html">AutocompleteExecuted</a></li>
<li><a class="xref" href="../../api/Discord.WebSocket.BaseSocketClient.html">UserCommandExecuted</a></li>
<li><a class="xref" href="../../api/Discord.WebSocket.BaseSocketClient.html">MessageCommandExecuted</a></li>
<li><a class="xref" href="../../api/Discord.WebSocket.BaseSocketClient.html">ModalExecuted</a></li>
</ul>
<p>These events will trigger for the specific type of interaction they inherit their name from. The <a class="xref" href="../../api/Discord.WebSocket.BaseSocketClient.html">InteractionCreated</a> event will trigger for all.
An example of executing a command from an event can be seen here:</p>
<pre><code class="lang-csharp" name="Command Event Example">// Theres multiple ways to subscribe to the event, depending on your application. Please use the approach fit to your type of client.
// DiscordSocketClient:
_socketClient.InteractionCreated += async (x) =&gt;
{
    var ctx = new SocketInteractionContext(_socketClient, x);
    await _interactionService.ExecuteCommandAsync(ctx, _serviceProvider);
}

// DiscordShardedClient:
_shardedClient.InteractionCreated += async (x) =&gt;
{
    var ctx = new ShardedInteractionContext(_shardedClient, x);
    await _interactionService.ExecuteCommandAsync(ctx, _serviceProvider);
}
</code></pre>
<p>Commands can be either executed on the gateway thread or on a separate thread from the thread pool.
This behaviour can be configured by changing the <code>RunMode</code> property of <code>InteractionServiceConfig</code> or by setting the <em>runMode</em> parameter of a command attribute.</p>
<div class="WARNING">
<h5>Warning</h5>
<p>In the example above, no form of post-execution is presented.
Please carefully read the <a class="xref" href="post-execution.html">Post-Execution Documentation</a> for the best approach in resolving the result based on your <code>RunMode</code>.</p>
</div>
<p>You can also configure the way <a class="xref" href="../../api/Discord.Interactions.InteractionService.html">InteractionService</a> executes the commands.
By default, commands are executed using <code>ConstructorInfo.Invoke()</code> to create module instances and
<code>MethodInfo.Invoke()</code> method for executing the method bodies.
By setting, <code>InteractionServiceConfig.UseCompiledLambda</code> to <code>true</code>, you can make <a class="xref" href="../../api/Discord.Interactions.InteractionService.html">InteractionService</a> create module instances and execute commands using
<em>Compiled Lambda</em> expressions. This cuts down on command execution time but it might add some memory overhead.</p>
<p>Time it takes to create a module instance and execute a <code>Task.Delay(0)</code> method using the Reflection methods compared to Compiled Lambda expressions:</p>
<table>
<thead>
<tr>
<th>Method</th>
<th style="text-align: right;">Mean</th>
<th style="text-align: right;">Error</th>
<th style="text-align: right;">StdDev</th>
</tr>
</thead>
<tbody>
<tr>
<td>ReflectionInvoke</td>
<td style="text-align: right;">225.93 ns</td>
<td style="text-align: right;">4.522 ns</td>
<td style="text-align: right;">7.040 ns</td>
</tr>
<tr>
<td>CompiledLambda</td>
<td style="text-align: right;">48.79 ns</td>
<td style="text-align: right;">0.981 ns</td>
<td style="text-align: right;">1.276 ns</td>
</tr>
</tbody>
</table>
<h2 id="registering-commands-to-discord">Registering Commands to Discord</h2>
<p>Application commands loaded to the Interaction Service can be registered to Discord using a number of different methods.
In most cases <code>RegisterCommandsGloballyAsync()</code> and <code>RegisterCommandsToGuildAsync()</code> are the methods to use.
Command registration methods can only be used after the gateway client is ready or the rest client is logged in.</p>
<pre><code class="lang-csharp" name="Registering Commands Example">#if DEBUG
    await interactionService.RegisterCommandsToGuildAsync(&lt;test_guild_id&gt;);
#else
    await interactionService.RegisterCommandsGloballyAsync();
#endif
</code></pre>
<p>Methods like <code>AddModulesToGuildAsync()</code>, <code>AddCommandsToGuildAsync()</code>, <code>AddModulesGloballyAsync()</code> and <code>AddCommandsGloballyAsync()</code>
can be used to register cherry picked modules or commands to global/guild scopes.</p>
<div class="NOTE">
<h5>Note</h5>
<p><a class="xref" href="../../api/Discord.Interactions.DontAutoRegisterAttribute.html">DontAutoRegisterAttribute</a> can be used on module classes to prevent <code>RegisterCommandsGloballyAsync()</code> and <code>RegisterCommandsToGuildAsync()</code> from registering them to the Discord.</p>
</div>
<h2 id="interaction-utility">Interaction Utility</h2>
<p>Interaction Service ships with a static <code>InteractionUtility</code>
class which contains some helper methods to asynchronously waiting for Discord Interactions.
For instance, <code>WaitForInteractionAsync()</code> method allows you to wait for an Interaction for a given amount of time.
This method returns the first encountered Interaction that satisfies the provided predicate.</p>
<div class="WARNING">
<h5>Warning</h5>
<p>If you are running the Interaction Service on <code>RunMode.Sync</code> you should avoid using this method in your commands,
as it will block the gateway thread and interrupt your bots connection.</p>
</div>
<h2 id="webhook-based-interactions">Webhook Based Interactions</h2>
<p>Instead of using the gateway to receive Discord Interactions, Discord allows you to receive Interaction events over Webhooks.
Interaction Service also supports this Interaction type but to be able to
respond to the Interactions within your command modules you need to perform the following:</p>
<ul>
<li>Make your modules inherit <code>RestInteractionModuleBase</code></li>
<li>Set the <code>ResponseCallback</code> property of <code>InteractionServiceConfig</code> so that the <code>ResponseCallback</code>
delegate can be used to create HTTP responses from a deserialized json object string.</li>
<li>Use the interaction endpoints of the module base instead of the interaction object (ie. <code>RespondAsync()</code>, <code>FollowupAsync()</code>...).</li>
</ul>
<h2 id="localization">Localization</h2>
<p>Discord Slash Commands support name/description localization. Localization is available for names and descriptions of Slash Command Groups (<a class="xref" href="../../api/Discord.Interactions.GroupAttribute.html">GroupAttribute</a>), Slash Commands (<a class="xref" href="../../api/Discord.Interactions.SlashCommandAttribute.html">SlashCommandAttribute</a>), Slash Command parameters and Slash Command Parameter Choices. Interaction Service can be initialized with an <code>ILocalizationManager</code> instance in its config which is used to create the necessary localization dictionaries on command registration. Interaction Service has two built-in <code>ILocalizationManager</code> implementations: <code>ResxLocalizationManager</code> and <code>JsonLocalizationManager</code>.</p>
<h3 id="resxlocalizationmanager">ResXLocalizationManager</h3>
<p><code>ResxLocalizationManager</code> uses <code>.</code> delimited key names to traverse the resource files and get the localized strings (<code>group1.group2.command.parameter.name</code>). A <code>ResxLocalizationManager</code> instance must be initialized with a base resource name, a target assembly and a collection of <code>CultureInfo</code>s. Every key path must end with either <code>.name</code> or <code>.description</code>, including parameter choice strings. <a href="https://www.nuget.org/packages/Discord.Tools.LocalizationTemplate.Resx">Discord.Tools.LocalizationTemplate.Resx</a> dotnet tool can be used to create localization file templates.</p>
<h3 id="jsonlocalizationmanager">JsonLocalizationManager</h3>
<p><code>JsonLocalizationManager</code> uses a nested data structure similar to Discord's Application Commands schema. You can get the Json schema <a href="https://gist.github.com/Cenngo/d46a881de24823302f66c3c7e2f7b254">here</a>. <code>JsonLocalizationManager</code> accepts a base path and a base file name and automatically discovers every resource file ( \basePath\fileName.locale.json ). A Json resource file should have a structure similar to:</p>
<pre><code class="lang-json">{
    &quot;command_1&quot;:{
        &quot;name&quot;: &quot;localized_name&quot;,
        &quot;description&quot;: &quot;localized_description&quot;,
        &quot;parameter_1&quot;:{
            &quot;name&quot;: &quot;localized_name&quot;,
            &quot;description&quot;: &quot;localized_description&quot;
        }
    },
    &quot;group_1&quot;:{
        &quot;name&quot;: &quot;localized_name&quot;,
        &quot;description&quot;: &quot;localized_description&quot;,
        &quot;command_1&quot;:{
            &quot;name&quot;: &quot;localized_name&quot;,
             &quot;description&quot;: &quot;localized_description&quot;,
             &quot;parameter_1&quot;:{
                 &quot;name&quot;: &quot;localized_name&quot;,
                  &quot;description&quot;: &quot;localized_description&quot;
            },
            &quot;parameter_2&quot;:{
                 &quot;name&quot;: &quot;localized_name&quot;,
                  &quot;description&quot;: &quot;localized_description&quot;
            }
        }
    }
}
</code></pre>
<h2 id="user-apps">User Apps</h2>
<p>User apps are the kind of Discord applications that are installed onto a user instead of a guild, thus making commands usable anywhere on Discord. Note that only users who have installed the application will see the commands. This sample shows you how to create a simple user install command.</p>
<pre><code class="lang-csharp" name="Registering Commands Example">
// This parameteres can be configured on the module level
// Set supported command context types to Bot DMs and Private Channels (regular DM &amp; GDM)
[CommandContextType(InteractionContextType.BotDm, InteractionContextType.PrivateChannel)]
// Set supported integration installation type to User Install
[IntegrationType(ApplicationIntegrationType.UserInstall)]
public class CommandModule() : InteractionModuleBase&lt;SocketInteractionContext&gt;
{
    [SlashCommand(&quot;test&quot;, &quot;Just a test command&quot;)]
    public async Task TestCommand()
        =&gt; await RespondAsync(&quot;Hello There&quot;);

    // But can also be overridden on the command level
    [CommandContextType(InteractionContextType.BotDm, InteractionContextType.PrivateChannel, InteractionContextType.Guild)]
    [IntegrationType(ApplicationIntegrationType.GuildInstall)]
    [SlashCommand(&quot;echo&quot;, &quot;Echo the input&quot;)]
    public async Task EchoCommand(string input)
        =&gt; await RespondAsync($&quot;You said: {input}&quot;);
}
</code></pre>
</article>

        <div class="contribution d-print-none">
          <a href="https://github.com/discord-net/Discord.Net/blob/dev/docs/guides/int_framework/intro.md/#L1" class="edit-link">Edit this page</a>
        </div>

        <div class="next-article d-print-none border-top" id="nextArticle"></div>

      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>

    <div class="container-xxl search-results" id="search-results"></div>

    <footer class="border-top text-secondary">
      <div class="container-xxl">
        <div class="flex-fill">
          Discord.Net © 2015-2024 3.17.0
        </div>
      </div>
    </footer>
  </body>
</html>
