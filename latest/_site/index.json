{
  "faq/commands/dependency-injection.html": {
    "href": "faq/commands/dependency-injection.html",
    "title": "Questions about Dependency Injection with Commands | Discord.Net Documentation",
    "keywords": "Dependency-injection-related Questions In the following section, you will find common questions and answers to utilizing dependency injection with @Discord.Commands, as well as common troubleshooting steps regarding DI. What is a service? Why does my module not hold any data after execution? In Discord.Net, modules are created similarly to ASP.NET, meaning that they have a transient nature; modules are spawned whenever a request is received, and are killed from memory when the execution finishes. In other words, you cannot store persistent data inside a module. Consider using a service if you wish to workaround this. Service is often used to hold data externally so that they persist throughout execution. Think of it like a chest that holds whatever you throw at it that won't be affected by anything unless you want it to. Note that you should also learn Microsoft's implementation of Dependency Injection ( video ) before proceeding, as well as how it works in Discord.Net . A brief example of service and dependency injection can be seen below. public class MyService { public string MyCoolString { get; set; } } public class Setup { public IServiceProvider BuildProvider() => new ServiceCollection() .AddSingleton<MyService>() .BuildServiceProvider(); } public class MyModule : ModuleBase<SocketCommandContext> { // Inject via public settable prop public MyService MyService { get; set; } // ...or via the module's constructor // private readonly MyService _myService; // public MyModule (MyService myService) => _myService = myService; [Command(\"string\")] public Task GetOrSetStringAsync(string input) { if (string.IsNullOrEmpty(_myService.MyCoolString)) _myService.MyCoolString = input; return ReplyAsync(_myService.MyCoolString); } } Why is my CommandService complaining about a missing dependency? If you encounter an error similar to Failed to create MyModule, dependency MyExternalDependency was not found. , you may have forgotten to add the external dependency to the dependency container. Starting from Discord.Net 2.0, all dependencies required by each module must be present when the module is loaded into the CommandService . This means when loading the module, you must pass a valid IServiceProvider with the dependency loaded before the module can be successfully registered. For example, if your module, MyModule , requests a DatabaseService in its constructor, the DatabaseService must be present in the IServiceProvider when registering MyModule . public class MyModule : ModuleBase<SocketCommandContext> { private readonly DatabaseService _dbService; public MyModule(DatabaseService dbService) => _dbService = dbService; } public class CommandHandler { private readonly CommandService _commands; private readonly IServiceProvider _services; public CommandHandler(DiscordSocketClient client) { _services = new ServiceCollection() .AddService<CommandService>() .AddService(client) // We are missing DatabaseService! .BuildServiceProvider(); } public async Task RegisterCommandsAsync() { // ... // The method fails here because DatabaseService is a required // dependency and cannot be resolved by the dependency // injection service at runtime since the service is not // registered in this instance of _services. await _commands.AddModulesAsync(Assembly.GetEntryAssembly(), _services); // ... } }"
  },
  "faq/misc/legacy.html": {
    "href": "faq/misc/legacy.html",
    "title": "Questions about Legacy Versions | Discord.Net Documentation",
    "keywords": "Legacy Questions This section refers to legacy library-related questions that do not apply to the latest or recent version of the Discord.Net library. X, Y, Z does not work! It doesn't return a valid value anymore. If you are currently using an older version of the stable branch, please upgrade to the latest pre-release version to ensure maximum compatibility. Several features may be broken in older versions and will likely not be fixed in the version branch due to their breaking nature. Visit the repo's release tag to see the latest public pre-release. I came from an earlier version of Discord.Net 1.0, and DependencyMap doesn't seem to exist anymore in the later revision? What happened to it? The DependencyMap has been replaced with Microsoft's DependencyInjection Abstractions. An example usage can be seen here ."
  },
  "faq/commands/general.html": {
    "href": "faq/commands/general.html",
    "title": "General Questions about Commands | Discord.Net Documentation",
    "keywords": "Command-related Questions In the following section, you will find commonly asked questions and answered regarding general command usage when using @Discord.Commands. How can I restrict some of my commands so only specific users can execute them? Based on how you want to implement the restrictions, you can use the built-in RequireUserPermission precondition, which allows you to restrict the command based on the user's current permissions in the guild or channel ( e.g., GuildPermission.Administrator , ChannelPermission.ManageMessages ). If, however, you wish to restrict the commands based on the user's role, you can either create your custom precondition or use Joe4evr's Preconditions Addons that provides a few custom preconditions that aren't provided in the stock library. Its source can also be used as an example for creating your custom preconditions. Why am I getting an error about Assembly.GetEntryAssembly ? You may be confusing @Discord.Commands.CommandService.AddModulesAsync* with @Discord.Commands.CommandService.AddModuleAsync*. The former is used to add modules via the assembly, while the latter is used to add a single module. What does [Remainder] do in the command signature? The RemainderAttribute leaves the string unparsed, meaning you do not have to add quotes around the text for the text to be recognized as a single object. Please note that if your method has multiple parameters, the remainder attribute can only be applied to the last parameter. // Input: // !echo Coffee Cake // Output: // Coffee Cake [Command(\"echo\")] public Task EchoRemainderAsync([Remainder]string text) => ReplyAsync(text); // Output: // CommandError.BadArgCount [Command(\"echo-hassle\")] public Task EchoAsync(string text) => ReplyAsync(text); // The message would be seen as having multiple parameters, // while the method only accepts one. // Wrapping the message in quotes solves this. // This way, the system knows the entire message is to be parsed as a // single String. // e.g., // !echo \"Coffee Cake\" Discord.Net keeps saying that a MessageReceived handler is blocking the gateway, what should I do? By default, the library warns the user about any long-running event handler that persists for more than 3 seconds . Any event handlers that are run on the same thread as the gateway task, the task in charge of keeping the connection alive, may block the processing of heartbeat, and thus terminating the connection. In this case, the library detects that a MessageReceived event handler is blocking the gateway thread. This warning is typically associated with the command handler as it listens for that particular event. If the command handler is blocking the thread, then this might mean that you have a long-running command. Note In rare cases, runtime errors can also cause blockage, usually associated with Mono, which is not supported by this library. To prevent a long-running command from blocking the gateway thread, a flag called RunMode is explicitly designed to resolve this issue. There are 2 main RunMode s. RunMode.Sync RunMode.Async Sync is the default behavior and makes the command to be run on the same thread as the gateway one. Async will spin the task off to a different thread from the gateway one. Important While specifying RunMode.Async allows the command to be spun off to a different thread, keep in mind that by doing so, there will be potentially unwanted consequences . Before applying this flag, please consider whether it is necessary to do so. Further details regarding RunMode.Async can be found below. You can set the RunMode either by specifying it individually via the CommandAttribute or by setting the global default with the DefaultRunMode flag under CommandServiceConfig . CommandAttribute CommandServiceConfig [Command(\"process\", RunMode = RunMode.Async)] public async Task ProcessAsync(string input) { // Does heavy calculation here. await Task.Delay(TimeSpan.FromMinute(1)); await ReplyAsync(input); } public class Setup { private readonly CommandService _command; public Setup() { var config = new CommandServiceConfig{ DefaultRunMode = RunMode.Async }; _command = new CommandService(config); } } How does RunMode.Async work, and why is Discord.Net not using it by default? RunMode.Async works by spawning a new Task with an unawaited Task.Run , essentially making the task that is used to invoke the command task to be finished on a different thread. This design means that ExecuteAsync will be forced to return a successful ExecuteResult regardless of the actual execution result. The following are the known caveats with RunMode.Async , You can potentially introduce a race condition. Unnecessary overhead caused by the async state machine . ExecuteAsync will immediately return ExecuteResult instead of other result types (this is particularly important for those who wish to utilize RuntimeResult in 2.0). Exceptions are swallowed in the ExecuteAsync result. However, there are ways to remedy some of these. For #3, in Discord.Net 2.0, the library introduces a new event called CommandService.CommandExecuted , which is raised whenever the command is executed. This event will be raised regardless of the RunMode type and will return the appropriate execution result and the associated @Discord.Commands.CommandInfo if applicable. For #4, exceptions are caught in CommandService.Log event under LogMessage.Exception as CommandException and in the CommandService.CommandExecuted event under the IResult as ExecuteResult.Exception ."
  },
  "faq/basics/getting-started.html": {
    "href": "faq/basics/getting-started.html",
    "title": "Beginner Questions / How to Get Started | Discord.Net Documentation",
    "keywords": "Basic Concepts / Getting Started In this following section, you will find commonly asked questions and answers about how to get started with Discord.Net, as well as basic introduction to the Discord API ecosystem. How do I add my bot to my server/guild? You can do so by using the permission calculator provided by FiniteReality . This tool allows you to set permissions that the bot will be assigned with, and invite the bot into your guild. With this method, bots will also be assigned a unique role that a regular user cannot use; this is what we call a Managed role. Because you cannot assign this role to any other users, it is much safer than creating a single role which, intentionally or not, can be applied to other users to escalate their privilege. What is a token? A token is a credential used to log into an account. This information should be kept private and for your eyes only. Anyone with your token can log into your account. This risk applies to both user and bot accounts. That also means that you should never hardcode your token or add it into source control, as your identity may be stolen by scrape bots on the internet that scours through constantly to obtain a token. What is a client/user/object ID? Each user and object on Discord has its own snowflake ID generated based on various conditions. Anyone can see the ID; it is public. It is merely used to identify an object in the Discord ecosystem. Many things in the Discord ecosystem require an ID to retrieve or identify the said object. There are 2 common ways to obtain the said ID. Discord Developer Mode Escape Character By enabling the developer mode you can right click on most objects to obtain their snowflake IDs (please note that this may not apply to all objects, such as role IDs, or DM channel IDs). You can escape an object by using \\ in front the object in the Discord client. For example, when you do \\@Example#1234 in chat, it will return the user ID of the aforementioned user. How do I get the role ID? Warning Right-clicking on the role and copying the ID will not work. This will only copy the message ID. Several common ways to do this: Make the role mentionable and mention the role, and escape it using the \\ character in front. Inspect the roles collection within the guild via your debugger."
  },
  "faq/basics/client-basics.html": {
    "href": "faq/basics/client-basics.html",
    "title": "Basic Questions about Client | Discord.Net Documentation",
    "keywords": "Client Basics Questions In the following section, you will find commonly asked questions and answers about common issues that you may face when utilizing the various clients offered by the library. My client keeps returning 401 upon logging in! Warning Userbot/selfbot (logging in with a user token) is no longer supported with this library starting from 2.0, as logging in under a user account may result in account termination. For more information, see issue 827 & 958 , as well as the official Discord API Terms of Service . There are few possible reasons why this may occur. You are not using the appropriate TokenType . If you are using a bot account created from the Discord Developer portal, you should be using TokenType.Bot . You are not using the correct login credentials. Please keep in mind that a token is different from a client secret . How do I do X, Y, Z when my bot connects/logs on? Why do I get a NullReferenceException upon calling any client methods after connect? Your bot should not attempt to interact in any way with guilds/servers until the Ready event fires. When the bot connects, it first has to download guild information from Discord for you to get access to any server information; the client is not ready at this point. Technically, the GuildAvailable event fires once the data for a particular guild has downloaded; however, it is best to wait for all guilds to be downloaded. Once all downloads are complete, the Ready event is triggered, then you can proceed to do whatever you like. How do I get a message's previous content when that message is edited? If you need to do anything with messages (e.g., checking Reactions, checking the content of edited/deleted messages), you must set the MessageCacheSize in your DiscordSocketConfig settings in order to use the cached message entity. Read more about it here . Message Cache must be enabled. Hook the MessageUpdated event. This event provides a before and after object. Only messages received after the bot comes online will be available in the cache. What is a shard/sharded client, and how is it different from the DiscordSocketClient ? As your bot grows in popularity, it is recommended that you should section your bot off into separate processes. The DiscordShardedClient is essentially a class that allows you to easily create and manage multiple DiscordSocketClient instances, with each one serving a different amount of guilds. There are very few differences from the DiscordSocketClient class, and it is very straightforward to modify your existing code to use a DiscordShardedClient when necessary. You need to specify the total amount of shards, or shard ids, via DiscordShardedClient 's constructors. The Connected , Disconnected , Ready , and LatencyUpdated events are replaced with ShardConnected , ShardDisconnected , ShardReady , and ShardLatencyUpdated . Every event handler you apply/remove to the DiscordShardedClient is applied/removed to each shard. If you wish to control a specific shard's events, you can access an individual shard through the Shards property. If you do not wish to use the DiscordShardedClient and instead reuse the same DiscordSocketClient code and manually shard them, you can do so by specifying the ShardId for the DiscordSocketConfig and pass that to the DiscordSocketClient 's constructor."
  },
  "faq/misc/glossary.html": {
    "href": "faq/misc/glossary.html",
    "title": "Common Terminologies / Glossary | Discord.Net Documentation",
    "keywords": "Glossary This is an additional chapter for quick references to various common types that you may see within Discord.Net. To see more information regarding each type of object, click on the object to navigate to our API documentation page where you might find more explanation about it. Common Types A Guild ( IGuild ) is an isolated collection of users and channels, and are often referred to as \"servers\". Example: Discord API A Channel ( IChannel ) represents a generic channel. Example: #dotnet_discord-net See Channel Types Channel Types Message Channels A Text Channel ( ITextChannel ) is a message channel from a Guild. A DM Channel ( IDMChannel ) is a message channel from a DM. A Group Channel ( IGroupChannel ) is a message channel from a Group. This is rarely used due to the bot's inability to join groups. A Private Channel ( IPrivateChannel ) is a DM or a Group. A Message Channel ( IMessageChannel ) can be any of the above. Misc Channels A Guild Channel ( IGuildChannel ) is a guild channel in a guild. This can be any channels that may exist in a guild. A Voice Channel ( IVoiceChannel ) is a voice channel in a guild. A Category Channel ( ICategoryChannel ) (2.0+) is a category that holds one or more sub-channels. A Nested Channel ( INestedChannel ) (2.0+) is a channel that can exist under a category. Emoji Types An Emote ( Emote ) is a custom emote from a guild. Example: <:dotnet:232902710280716288> An Emoji ( Emoji ) is a Unicode emoji. Example: 👍 Activity Types A Game ( Game ) refers to a user's game activity. A Rich Presence ( RichGame ) refers to a user's detailed gameplay status. Visit Rich Presence Intro on Discord docs for more info. A Streaming Status ( StreamingGame ) refers to user's activity for streaming on services such as Twitch. A Spotify Status ( SpotifyGame ) (2.0+) refers to a user's activity for listening to a song on Spotify."
  },
  "guides/voice/sending-voice.html": {
    "href": "guides/voice/sending-voice.html",
    "title": "Sending Voice | Discord.Net Documentation",
    "keywords": "Information on this page is subject to change! Warning This article is out of date, and has not been rewritten yet. Information is not guaranteed to be accurate. Installing Audio requires two native libraries, libsodium and opus . Both of these libraries must be placed in the runtime directory of your bot. (When developing on .NET Framework, this would be bin/debug , when developing on .NET Core, this is where you execute dotnet run from; typically the same directory as your csproj). For Windows Users, precompiled binaries are available for your convienence here . For Linux Users, you will need to compile Sodium and Opus from source, or install them from your package manager. Joining a Channel Joining a channel is the first step to sending audio, and will return an IAudioClient to send data with. To join a channel, simply await ConnectAsync on any instance of an @Discord.IAudioChannel. // The command's Run Mode MUST be set to RunMode.Async, otherwise, being connected to a voice channel will block the gateway thread. [Command(\"join\", RunMode = RunMode.Async)] public async Task JoinChannel(IVoiceChannel channel = null) { // Get the audio channel channel = channel ?? (Context.User as IGuildUser)?.VoiceChannel; if (channel == null) { await Context.Channel.SendMessageAsync(\"User must be in a voice channel, or a voice channel must be passed as an argument.\"); return; } // For the next step with transmitting audio, you would want to pass this Audio Client in to a service. var audioClient = await channel.ConnectAsync(); } Warning Commands which mutate voice states, such as those where you join/leave an audio channel, or send audio, should use RunMode.Async . RunMode.Async is necessary to prevent a feedback loop which will deadlock clients in their default configuration. If you know that you're running your commands in a different task than the gateway task, RunMode.Async is not required. The client will sustain a connection to this channel until it is kicked, disconnected from Discord, or told to disconnect. It should be noted that voice connections are created on a per-guild basis; only one audio connection may be open by the bot in a single guild. To switch channels within a guild, invoke ConnectAsync on another voice channel in the guild. Transmitting Audio With FFmpeg FFmpeg is an open source, highly versatile AV-muxing tool. This is the recommended method of transmitting audio. Before you begin, you will need to have a version of FFmpeg downloaded and placed somewhere in your PATH (or alongside the bot, in the same location as libsodium and opus). Windows binaries are available on FFmpeg's download page . First, you will need to create a Process that starts FFmpeg. An example of how to do this is included below, though it is important that you return PCM at 48000hz. Note As of the time of this writing, Discord.Audio struggles significantly with processing audio that is already opus-encoded; you will need to use the PCM write streams. private Process CreateStream(string path) { return Process.Start(new ProcessStartInfo { FileName = \"ffmpeg\", Arguments = $\"-hide_banner -loglevel panic -i \\\"{path}\\\" -ac 2 -f s16le -ar 48000 pipe:1\", UseShellExecute = false, RedirectStandardOutput = true, }); } Next, to transmit audio from FFmpeg to Discord, you will need to pull an AudioOutStream from your IAudioClient . Since we're using PCM audio, use IAudioClient.CreatePCMStream . The sample rate argument doesn't particularly matter, so long as it is a valid rate (120, 240, 480, 960, 1920, or 2880). For the sake of simplicity, I recommend using 1920. Channels should be left at 2 , unless you specified a different value for -ac 2 when creating FFmpeg. Finally, audio will need to be piped from FFmpeg's stdout into your AudioOutStream. This step can be as complex as you'd like it to be, but for the majority of cases, you can just use Stream.CopyToAsync , as shown below. If you are implementing a queue for sending songs, it's likely that you will want to wait for audio to stop playing before continuing on to the next song. You can await AudioOutStream.FlushAsync to wait for the audio client's internal buffer to clear out. private async Task SendAsync(IAudioClient client, string path) { // Create FFmpeg using the previous example using (var ffmpeg = CreateStream(path)) using (var output = ffmpeg.StandardOutput.BaseStream) using (var discord = client.CreatePCMStream(AudioApplication.Mixed)) { try { await output.CopyToAsync(discord); } finally { await discord.FlushAsync(); } } }"
  },
  "guides/introduction/intro.html": {
    "href": "guides/introduction/intro.html",
    "title": "Introduction to Discord.Net | Discord.Net Documentation",
    "keywords": "Introduction Looking to get started? Welcome! Before you dive into this library, however, you should have some decent understanding of the language you are about to use. This library touches on Task-based Asynchronous Pattern (TAP), polymorphism , interface and many more advanced topics extensively. Please make sure that you understand these topics to some extent before proceeding. With all that being said, feel free to visit us on Discord at the link below if you have any questions! An official collection of samples can be found in our GitHub repository . Note Please note that you should not try to blindly copy paste the code. The examples are meant to be a template or a guide. New to .NET/C#? All examples or snippets featured in this guide and all API documentation will be written in C#. If you are new to the language, using this wrapper may prove to be difficult, but don't worry! There are many resources online that can help you get started in the wonderful world of .NET. Here are some resources to get you started. C# Programming Guide (MSDN/Microsoft, Free) C# Fundamentals For Absolute Beginners (Channel9/Microsoft, Free) C# Path (Pluralsight, Paid) Still have questions? Please visit us at #dotnet_discord-net on the Discord API server. Describe the problem in details to us, what you've done, and, if any, the problematic code uploaded onto Hastebin ."
  },
  "guides/getting_started/terminology.html": {
    "href": "guides/getting_started/terminology.html",
    "title": "Terminology | Discord.Net Documentation",
    "keywords": "Terminology Preface Most terms for objects remain the same between 0.9 and 1.0 and above. The major difference is that the Server is now called Guild to stay in line with Discord internally. Implementation Specific Entities Discord.Net is split into a core library and two different implementations - Discord.Net.Core , Discord.Net.Rest , and Discord.Net.WebSockets . As a bot developer, you will only need to use Discord.Net.WebSockets , but you should be aware of the differences between them. Discord.Net.Core provides a set of interfaces that models Discord's API. These interfaces are consistent throughout all implementations of Discord.Net, and if you are writing an implementation-agnostic library or addon, you can rely on the core interfaces to ensure that your addon will run on all platforms. Discord.Net.Rest provides a set of concrete classes to be used strictly with the REST portion of Discord's API. Entities in this implementation are prefixed with Rest (e.g., RestChannel ). Discord.Net.WebSocket provides a set of concrete classes that are used primarily with Discord's WebSocket API or entities that are kept in cache. When developing bots, you will be using this implementation. All entities are prefixed with Socket (e.g., SocketChannel )."
  },
  "guides/deployment/deployment.html": {
    "href": "guides/deployment/deployment.html",
    "title": "Deploying the Bot | Discord.Net Documentation",
    "keywords": "Deploying a Discord.Net Bot After finishing your application, you may want to deploy your bot to a remote location such as a Virtual Private Server (VPS) or another computer so you can keep the bot up and running 24/7. Recommended VPS For small-medium scaled bots, a cheap VPS (~$5) might be sufficient enough. Here is a list of recommended VPS provider. DigitalOcean Description: American cloud infrastructure provider headquartered in New York City with data centers worldwide. Location(s): Asia: Singapore, India America: Canada, United States Europe: Netherlands, Germany, United Kingdom Based in: United States Vultr Description: DigitalOcean-like Location(s): Asia: Japan, Australia, Singapore America: United States Europe: United Kingdom, France, Netherlands, Germany Based in: United States OVH Description: French cloud computing company that offers VPS, dedicated servers and other web services. Location(s): Asia: Australia, Singapore America: United States, Canada Europe: United Kingdom, Poland, Germany Based in: Europe Scaleway Description: Cheap but powerful VPS owned by Online.net . Location(s): Europe: France, Netherlands Based in: Europe Time4VPS Description: Affordable and powerful VPS Hosting in Europe. Location(s): Europe: Lithuania Based in: Europe .NET Core Deployment Note This section only covers the very basics of .NET Core deployment. To learn more about .NET Core deployment, visit .NET Core application deployment by Microsoft. When redistributing the application - whether for deployment on a remote machine or for sharing with another user - you may want to publish the application; in other words, to create a self-contained package without installing the dependencies and the runtime on the target platform. Framework-dependent Deployment To deploy a framework-dependent package (i.e. files to be used on a remote machine with the dotnet command), simply publish the package with: dotnet publish -c Release This will create a package with the least dependencies included with the application; however, the remote machine must have dotnet runtime installed before the remote could run the program. Tip Do not know how to run a .NET Core application with the dotnet runtime? Navigate to the folder of the program (typically under $projFolder/bin/Release ) and enter dotnet program.dll where program.dll is your compiled binaries. Self-contained Deployment To deploy a self-contained package (i.e. files to be used on a remote machine without the dotnet runtime), publish with a specific Runtime ID with the -r switch. This will create a package with dependencies compiled for the target platform, meaning that all the required dependencies will be included with the program. This will result in larger package size ; however, that means the copy of the runtime that can be run natively on the target platform. For example, the following command will create a Windows executable ( .exe ) that is ready to be executed on any Windows 10 x64 based machine: dotnet publish -c Release -r win10-x64"
  },
  "api/index.html": {
    "href": "api/index.html",
    "title": "API Documentation | Discord.Net Documentation",
    "keywords": "API Documentation This is where you will find documentation for all members and objects in Discord.Net. Commonly Used Entities @Discord.WebSocket @Discord.WebSocket.DiscordSocketClient @Discord.WebSocket.SocketGuildChannel @Discord.WebSocket.SocketGuildUser @Discord.WebSocket.SocketMessage @Discord.WebSocket.SocketRole"
  },
  "faq/basics/basic-operations.html": {
    "href": "faq/basics/basic-operations.html",
    "title": "Questions about Basic Operations | Discord.Net Documentation",
    "keywords": "Basic Operations Questions In the following section, you will find commonly asked questions and answers regarding basic usage of the library, as well as language-specific tips when using this library. How should I safely check a type? Warning Direct casting (e.g., (Type)type ) is the least recommended way of casting, as it can throw an InvalidCastException when the object isn't the desired type. Please refer to this post for more details. In Discord.Net, the idea of polymorphism is used throughout. You may need to cast the object as a certain type before you can perform any action. A good and safe casting example: public async Task MessageReceivedHandler(SocketMessage msg) { // Option 1: // Using the `as` keyword, which will return `null` if the object isn't the desired type. var usermsg = msg as SocketUserMessage; // We bail when the message isn't the desired type. if (msg == null) return; // Option 2: // Using the `is` keyword to cast (C#7 or above only) if (msg is SocketUserMessage usermsg) { // Do things } } How do I send a message? Tip The GetChannel method by default returns an IChannel , allowing channel types such as IVoiceChannel , ICategoryChannel to be returned; consequently, you cannot send a message to channels like those. Any implementation of IMessageChannel has a SendMessageAsync method. You can get the channel via GetChannel under the client. Remember, when using Discord.Net, polymorphism is a common recurring theme. This means an object may take in many shapes or form, which means casting is your friend. You should attempt to cast the channel as an IMessageChannel or any other entity that implements it to be able to message. How can I tell if a message is from X, Y, Z channel? You may check the message channel type. Visit Glossary to see the various types of channels. How can I get the guild from a message? There are 2 ways to do this. You can do either of the following, Cast the user as an IGuildUser and use its IGuild property. Cast the channel as an IGuildChannel and use its IGuild property. How do I add hyperlink text to an embed? Embeds can use standard markdown in the description field as well as in field values. With that in mind, links can be added with [text](link) . How do I add reactions to a message? Any entity that implements IUserMessage has an AddReactionAsync method. This method expects an IEmote as a parameter. In Discord.Net, an Emote represents a custom-image emote, while an Emoji is a Unicode emoji (standard emoji). Both Emoji and Emote implement IEmote and are valid options. Adding a reaction to another message Adding a reaction to a sent message // bail if the message is not a user one (system messages cannot have reactions) var usermsg = msg as IUserMessage; if (usermsg == null) return; // standard Unicode emojis Emoji emoji = new Emoji(\"👍\"); // or // Emoji emoji = new Emoji(\"\\uD83D\\uDC4D\"); // custom guild emotes Emote emote = Emote.Parse(\"<:dotnet:232902710280716288>\"); // using Emote.TryParse may be safer in regards to errors being thrown; // please note that the method does not verify if the emote exists, // it simply creates the Emote object for you. // add the reaction to the message await usermsg.AddReactionAsync(emoji); await usermsg.AddReactionAsync(emote); // capture the message you're sending in a variable var msg = await channel.SendMessageAsync(\"This will have reactions added.\"); // standard Unicode emojis Emoji emoji = new Emoji(\"👍\"); // or // Emoji emoji = new Emoji(\"\\uD83D\\uDC4D\"); // custom guild emotes Emote emote = Emote.Parse(\"<:dotnet:232902710280716288>\"); // using Emote.TryParse may be safer in regards to errors being thrown; // please note that the method does not verify if the emote exists, // it simply creates the Emote object for you. // add the reaction to the message await msg.AddReactionAsync(emoji); await msg.AddReactionAsync(emote); What is a \"preemptive rate limit?\" A preemptive rate limit is Discord.Net's way of telling you to slow down before you get hit by the real rate limit. Hitting a real rate limit might prevent your entire client from sending any requests for a period of time. This is calculated based on the HTTP header returned by a Discord response. Why am I getting so many preemptive rate limits when I try to add more than one reactions? This is due to how HTML header works, mistreating 0.25sec/action to 1sec. This causes the lib to throw preemptive rate limit more frequently than it should for methods such as adding reactions. Can I opt-out of preemptive rate limits? Unfortunately, not at the moment. See #401 ."
  },
  "index.html": {
    "href": "index.html",
    "title": "Home | Discord.Net Documentation",
    "keywords": "Discord.Net Documentation What is Discord.Net? Discord.Net is an asynchronous, multi-platform .NET Library used to interface with the Discord API . Where to begin? If this is your first time using Discord.Net, you should refer to the Intro for tutorials. More experienced users might want to refer to the API Documentation for a breakdown of the individual objects in the library. Additional Resources Discord API Guild - Look for #dotnet_discord-net GitHub NuGet MyGet Feed - Add-ons and nightly builds AppVeyor CI - Nightly builds via Continuous Integration"
  },
  "CHANGELOG.html": {
    "href": "CHANGELOG.html",
    "title": "Changelog | Discord.Net Documentation",
    "keywords": "Changelog [2.1.1] - 2019-06-08 Fixed #994: Remainder parameters now ignore character escaping, as there is no reason to escape characters here (2e95c49) #1316: Emote.Equals now pays no respect to the Name property, since Discord's API does not care about an emote's name (abf3e90) #1317: Emote.GetHashCode now pays no respect to the Name property, see above (1b54883) #1323: Optionals will no longer claim to be specified when a reaction message was not cached (1cc5d73) Log messages sourcing from REST events will no longer be raised twice (c78a679) News embeds will be processed as EmbedType.Unknown , rather than throwing an error and dropping the message (d287ed1) Changed #1311: Members may now be disconnected from voice channels by passing null as GuildUserProperties.Channel (fc48c66) #1313: IMessage.Tags now includes the EveryoneRole on @everyone and @here mentions (1f55f01) #1320: The maximum value for setting slow-mode has been updated to 6 hours, per the new API limit (4433ca7) Misc This library's compatibility with Semantic Versioning has been clarified. Please see the README (4d7de17) The depency on System.Interactive.Async has been bumped to 3.2.0 (3e65e03) [2.1.0] - 2019-05-18 Added #1236: Bulk deletes (for messages) may now be accessed via the MessagesBulkDeleted event (dec353e) #1240: OAuth applications utilizing the guilds.join scope may now add users to guilds through any client (1356ea9) #1255: Message and attachment spoilers may now be set or detected (f3b20b2) #1260: DiscordWebhookClient may be created from a Webhook URL (f2113c7) #1261: A GetCategoryChannel helper may now be used to retrieve category channels directly from socket guilds (e03c527) #1263: \"user joined the guild\" messages are now supported (00d3f5a) #1271: AuthorID may now be retrieved from message delete audit log entries (1ae4220) #1293: News Channels are now supported 📰 (9084c42) ExclusiveBulkDelete configuration setting can be used to control bulk delete event behavior (03e6401) Removed #1294: The IGuildUser overload of EmbedBuilder.WithAuthor no longer exists (b52b54d) Fixed #1256: Fetching audit logs no longer raises null reference exceptions when a webhook has been deleted (049b014) #1268: Null reference exceptions on MESSAGE_CREATE concerning partial member objects no longer occur (377622b) #1278: The token validator now internally pads tokens to the proper length (48b327b) #1292: Messages now properly initialize empty collections (b2ebc03) The DiscordSocketRestClient is now properly initialized (a44c13a) Exceptions in event handlers are now always logged (f6e3200) Changed #1305: Token validation will fail when tokens contain whitespace (bb61efa) Misc #1241: Added documentation samples for Webhooks (655a006) #1243: Happy new year 🎉 (0275f7d) #1257: Improved clarity in comments in the command samples (2473619) #1276: Documentation uses a relative path for the logo asset (b80f0e8) #1303: EmbedBuilder documentation now builds in the correct spot (51618e6) #1304: Updated documentation (4309550) CI for this project is now powered by Azure DevOps (this is not a sponsored message 🚀) (9b2bc18) IDisposableAnalyzers should now be a development dependency (8003ac8) [2.0.1] - 2019-01-04 Fixed #1226: Only escape the closing quotation mark of non-remainder strings (65b8c09) Commands with async RunModes will now propagate exceptions up to CommandExecuted (497918e) Misc #1225: Commands sample no longer hooks the log event twice (552f34c) #1227: The logo on the docs index page should scale responsively (d39bf6e) #1230: Replaced precondition sample on docs (feed4fd) [2.0.0] - 2018-12-28 Added #747: CommandService now has a CommandExecuted event (e991715) #765: Parameters may have a name specified via NameAttribute (9c81ab9) #773: Both socket clients inherit from BaseSocketClient (9b7afec) #785: Primitives now automatically load a NullableTypeReader (cb0ff78) #819: Support for Welcome Message channels (30e867a) #835: Emoji may now be managed from a bot (b4bf046) #843: Webhooks may now be managed from a bot (7b2ddd0) #863: An embed may be converted to an EmbedBuilder using the .ToEmbedBuilder() method (5218e6b) #877: Support for reading rich presences (34b4e5a) #888: Users may now opt-in to using a proxy (678a723) #906: API Analyzers to assist users when writing their bot (f69ef2a) #907: Full support for channel categories (030422f) #913: Animated emoji may be read and written (a19ff18) #915: Unused parameters may be discarded, rather than failing the command (5f46aef) #929: Standard EqualityComparers for use in LINQ operations with the library's entities (b5e7548) #934: Modules now contain an OnModuleBuilding method, which is invoked when the module is built (bb8ebc1) #952: Added 'All' permission set for categories (6d58796) #957: Ratelimit related objects now include request information (500f5f4) #962: Add GetRecommendedShardCountAsync (fc5e70c) #970: Add Spotify track support to user Activities (64b9cc7) #973: Added GetDefaultAvatarUrl to user (109f663) #978: Embeds can be attached alongside a file upload (e9f9b48) #984, #1089: VoiceServerUpdate events are now publically accessible (e775853, 48fed06) #996: Added DeleteMessageAsync to IMessageChannel (bc6009e) #1005: Added dedicated TimeSpan TypeReader which \"doesn't suck\" (b52af7a) #1009: Users can now specify the replacement behavior or default typereaders (6b7c6e9) #1020: Users can now specify parameters when creating channels (bf5275e) #1030: Added IsDeprecated , IsCustom properties to VoiceRegion (510f474) #1037: Added SocketUser.MutualGuilds , various extension methods to commands (637d9fc) #1043: Discord.Color is now compatible with System.Drawing.Color (c275e57) #1055: Added audit logs (39dffe8) #1056: Added GetBanAsync (97c8931) #1102: Added GetJumpUrl() to messages (afc3a9d) #1123: Commands can now accept named parameters (419c0a5) #1124: Preconditions can now set custom error messages (5677f23) #1126: Color now has equality (a2d8800) #1159: Guild channels can now by synced with their parent category (5ea1fb3) #1165: Bring Guild and Message models up to date with the API (d30d122) #1166: Added GetVoiceRegionsAsync to IGuild (00717cf) #1183: Added Add Guild Member endpoint for OAuth clients (8ef5f81) #1196: Channel position can now be specified when creating a channel (a64ab60) #1198: The Socket client can now access its underlying REST client (65afd37) #1213: Added GuildEmote#CreatorId (92bf836) 'html' variant added to the EmbedType enum (42c879c) Modules can now be nested in non-module classes (4edbd8d) Added BanAsync to guild members (1905fde) Added the permisison bit for priority speaker (c1d7818) All result types can use FromError (748e92b) Added support for reading/writing slow mode (97d17cf) Added markdown format for URLs (f005af3) Reactions can now be added to messages in bulk (5421df1) Fixed #742: DiscordShardedClient#GetGuildFor will now direct null guilds to Shard 0 (d5e9d6f) #743: Various issues with permissions and inheritance of permissions (f996338) #755: IRole.Mention will correctly tag the @everyone role (6b5a6e7) #768: CreateGuildAsync will include the icon stream (865080a) #866: Revised permissions constants and behavior (dec7cb2) #872: Bulk message deletion should no longer fail for incomplete batch sizes (804d918) #923: A null value should properly reset a user's nickname (227f61a) #938: The reconnect handler should no longer deadlock during Discord outages (73ac9d7) #941: Fix behavior of OverrideTypeReader (170a2e0) #945: Fix properties on SocketCategoryChannel (810f6d6) #959: Webhooks now use the correct parameter when assigning to the Avatar URL (8876597) #966: Correct the implementation of HasFlag and ResolveChannel in permissions (32ebdd5) #968: Add missing parameter in WebSocket4Net constructor (8537924) #981: Enforce a maximum value when parsing timestamps from Discord (bfaa6fc) #993: Null content will no longer null-ref on message sends/edits (55299ff) #1003: Fixed ordering of parameters in permissions classes (a06e212) #1010: EmbedBuilder no longer produces mutable embeds (2988b38) #1012: Embed.Length should now yield the correct results (a3ce80c) #1017: GetReactionUsersAsync includes query parameters (9b29c00) #1022: GetReactionUsersAsync is now correctly paginated (79811d0) #1023: Fix/update invite-related behaviors (7022149) #1031: Messages with no guild-specific data should no longer be lost (3631886) #1036: Fixed cases where RetryMode.RetryRatelimit were ignored (c618cb3) #1044: Populate the guild in SocketWebhookUser (6a7810b) #1048: The REST client will now create a full GuildUser object (033d312) #1049: Fixed null-ref in GetShardIdFor (7cfed7f) #1059: Include 'view channel' in voice channel's All permissions set (e764daf) #1083: Default type readers will now be properly replaced (4bc06a0) #1093: Fixed race condition in audio client authentication (322d46e) #1139: Fixed consistency in exceptions (9e9a11d) #1151: GetReactionUsersAsync now uses the correct pagination constant (c898325) #1163: Reaction ratelimits are now placed in the same bucket, treated correctly (5ea1fb3) #1186: Webhooks can now send files with embeds correctly (c1d5152) #1192: CommandExecuted no longer fires twice for RuntimeResults (10233f3) #1195: Channel Create audit log events properly deserialize (dca6c33) #1202: The UDP client should no longer be used after disposed (ccb16e4) #1203: The Audio client should no longer lock up on disconnect (2c93363) #1209: MessageUpdated should no longer pass a null after object (91e0f03) Ignore messages with no ID in bulk delete (676be40) No longer attempt to load generic types as modules (b1eaa44) No longer complain when a PRESENCES_REPLACE update is received (beb3d46) CommandExecuted will be raised on async exception failures (6260749) ExecuteResult now contains the entire exception, not an abridged message (f549da5) CommandExecuted will no longer be raised twice for exceptions (aec7105) The default WebSocket will now close correctly (ac389f5) Changed #731: IUserMessage#GetReactionUsersAsync now takes an IEmote instead of a string (5d7f2fc) #744: IAsyncEnumerable has been redesigned (5bbd9bb) #777: IGuild#DefaultChannel will now resolve the first accessible channel, per changes to Discord (1ffcd4b) #781: Attempting to add or remove a member's EveryoneRole will throw (506a6c9) #801: EmbedBuilder will no longer implicitly convert to Embed , you must build manually (94f7dd2) #804: Command-related tasks will have the 'async' suffix (14fbe40) #812: The WebSocket4Net provider has been bumped to version 0.15, allowing support for .NET Standard apps (e25054b) #829: DeleteMessagesAsync moved from IMessageChannel to ITextChannel (e00f17f) #853: WebSocket will now use zlib-stream compression (759db34) #874: The ReadMessages permission is moving to ViewChannel (edfbd05) #877: Refactored Games into Activities (34b4e5a) #943: Multiple types of quotation marks can now be parsed (thanks 🍎) (cee71ef) #955: The GameParty model will now use long values (178ea8d) #986: Expose the internal entity TypeReaders (660fec0) #992: Throw an exception when trying to modify someone else's message (d50fc3b) #998: Commands can specify their own IgnoreExtraArgs behavior (6d30100) #1033: The ReadMessages permission bit is now named ViewChannel (5f084ad) #1042: Content parameter of SendMessageAsync is now optional (0ba8b06) #1057: An audio channel's ConnectAsync now allows users to handle the voice connection elsewhere, such as in Lavalink (890904f) #1094: Overhauled invites, added vanity invite support (ffe994a) #1108: Reactions now use the undocumented 1/.25 ratelimit, making them 4x faster (6b21b11) #1128: Bot tokens will now be validated for common mishaps before use (2de6cef) #1140: Check the invite maxAge parameter before making the request (649a779) #1164: All command results will now be raised in CommandExecuted (10f67a8) #1171: Clients have been changed to properly make use of IDisposable (7366cd4) #1172: Invite related methods were moved from IGuildChannel to INestedChannel (a3f5e0b) #1200: HasPrefix extensions now check for null values first (46e2674) IGuildChannel#Nsfw moved to ITextChannel , now maps to the API property (608bc35) Preemptive ratelimits are now logged under verbose, rather than warning. (3c1e766) The default InviteAge when creating Invites is now 24 hours (9979a02) All parameters to ReplyAsync have been made optional (b38dca7) The socket client will now use additional fields to fill in member/guild information on messages (8fb2c71) The Audio Client now uses Voice WS v3 (9ba38d7) Removed #790: Redundant overloads for AddField removed from EmbedBuilder (479361b) #925: RPC is no longer being maintained nor packaged (b30af57) #958: Remove support for user tokens (2fd4f56) User logins (including selfbots) are no longer supported (fc5adca) Misc #786: Unit tests for the Color structure (22b969c) #828: We now include a contributing guide (cd82a0f) #876: We now include a standard editorconfig (5c8c784) #963: Docs now include a release version, build instructions (88e6244) #964: Fix documentation spelling of 'echoes' (fda19b5) #967: Unit test permissions (63e6704) #968: Bumped version of WebSocket4Net to 0.15.2 (8537924) #972: Include sample bots in the source repository (217ec34) #1046: We now support .NET Standard 2.0 (bbbac85) #1114: Various performance optimizations (82cfdff) #1149: The CI will now test on Ubuntu as well as Windows (674a0fc) #1161: The entire documentation has been rewritten, all core entities were docstringed (ff0fea9) #1175: Documentation changes in command samples (fb8dbca) #1177: Added documentation for sharded bots (00097d3) #1219: The project now has a logo! 🎉 (5750c3e) This project is now licensed to the Discord.Net contributors (710e182) Added templates for pull requests (f2ddf51) Fixed documentation layout for the logo (bafdce4) [1.0.2] - 2017-09-09 Fixed Guilds utilizing Channel Categories will no longer crash bots on the READY event. [1.0.1] - 2017-07-05 Fixed #732: Fixed parameter preconditions not being loaded from class-based modules (b6dcc9e) #726: Fixed CalculateScore throwing an ArgumentException for missing parameters (7597cf5) EmbedBuilder URI validation should no longer throw NullReferenceExceptions in certain edge cases (d89804d) Fixed module auto-detection for nested modules (d2afb06) Changed ShardedCommandContext now inherits from SocketCommandContext (8cd99be)"
  },
  "guides/getting_started/nightlies.html": {
    "href": "guides/getting_started/nightlies.html",
    "title": "Installing Nightly Build | Discord.Net Documentation",
    "keywords": "Installing Discord.Net Nightly Build Before Discord.Net pushes a new set of features into the stable version, we use nightly builds to test the features with the community for an extensive period of time. Each nightly build is compiled by AppVeyor whenever a new commit is made and will be pushed to our MyGet feed. Important Although nightlies are generally stable and have more features and bug fixes than the current stable build on NuGet, there will be breaking changes during the development or breaking bugs; these bugs are usually fixed as soon as they are discovered, but you should still be aware of that. Installing with MyGet (Recommended) MyGet is typically used by many development teams to publish their latest pre-release packages before the features are finalized and pushed to NuGet. The following is the feed link of Discord.Net, https://www.myget.org/F/discord-net/api/v3/index.json Depending on which IDE you use, there are many different ways of adding the feed to your package source. Using Visual Studio Using dotnet CLI Using Local NuGet.Config Go to Tools > NuGet Package Manager > Package Manager Settings Go to Package Sources Click on the add icon Fill in the desired name and source as shown below and hit Update Note Remember to tick the Include pre-release checkbox to see the nightly builds! Launch your terminal Navigate to where your *.csproj is located Type dotnet add package Discord.Net --source https://www.myget.org/F/discord-net/api/v3/index.json If you plan on deploying your bot or developing outside of Visual Studio, you will need to create a local NuGet configuration file for your project. To do this, create a file named NuGet.Config alongside the root of your application, where the project is located. Paste the following snippets into this configuration file, adding any additional feeds if necessary. <?xml version=\"1.0\" encoding=\"utf-8\"?> <configuration> <packageSources> <add key=\"discord.net ci feed\" value=\"https://www.myget.org/F/discord-net/api/v3/index.json\" /> </packageSources> </configuration> After which, you may install the packages by directly modifying the project file and specifying a version, or by using the Package Manager Console ( Install-Package Discord.Net -IncludePrerelease ). Installing from AppVeyor Artifacts As mentioned in the first paragraph, we utilize AppVeyor to perform automated tests and publish the new build. During the publishing process, we also upload the NuGet packages onto AppVeyor's Artifact collection. The latest build status can be found within our AppVeyor project . In the project, you may find our latest build including the aforementioned artifacts. In the artifacts collection, you should see the latest packages packed in *.nupkg form which you could download from and use."
  },
  "guides/getting_started/installing.html": {
    "href": "guides/getting_started/installing.html",
    "title": "Installing Discord.Net | Discord.Net Documentation",
    "keywords": "Discord.Net Installation Discord.Net is distributed through the NuGet package manager; the most recommended way for you to install this library. Alternatively, you may also compile this library yourself should you so desire. Supported Platforms Discord.Net targets .NET Standard both 1.3 and 2.0; this also means that creating applications using the latest version of .NET Core is the most recommended. If you are bound by Windows-specific APIs or other limitations, you may also consider targeting .NET Framework 4.6.1 or higher. Warning Using this library with Mono is not supported until further notice. It is known to have issues with the library's WebSockets implementation and may crash the application upon startup. Installing with NuGet Release builds of Discord.Net will be published to the official NuGet feed . Development builds of Discord.Net, as well as add-ons, will be published to our MyGet feed . See Installing Nightly Build to learn more. Using Visual Studio Using JetBrains Rider Using Visual Studio Code Using dotnet CLI Create a new solution for your bot In the Solution Explorer, find the \"Dependencies\" element under your bot's project Right click on \"Dependencies\", and select \"Manage NuGet packages\" In the \"Browse\" tab, search for Discord.Net Install the Discord.Net package Create a new solution for your bot Open the NuGet window (Tools > NuGet > Manage NuGet packages for Solution) In the \"Packages\" tab, search for Discord.Net Install by adding the package to your project Create a new project for your bot Add Discord.Net to your *.csproj <Project Sdk=\"Microsoft.NET.Sdk\"> <!-- The following may differ depending on the latest version of .NET Core or Discord.Net. --> <PropertyGroup> <OutputType>Exe</OutputType> <TargetFramework>netcoreapp2.1</TargetFramework> </PropertyGroup> <ItemGroup> <PackageReference Include=\"Discord.Net\" Version=\"2.0.0\" /> </ItemGroup> </Project> Launch your terminal Navigate to where your *.csproj is located Enter dotnet add package Discord.Net Compiling from Source In order to compile Discord.Net, you will need the following: Using Visual Studio Visual Studio 2017 .NET Core SDK The .NET Core and Docker workload is required during Visual Studio installation. Using Command Line .NET Core SDK Additional Information Installing on Unsupported WebSocket Platform When running any Discord.Net-powered bot on an older operating system (e.g. Windows 7) that does not natively support WebSocket, you may encounter a PlatformNotSupportedException upon connecting. You may resolve this by either targeting .NET Core 2.1 or later, or by installing one or more custom packages as listed below. Targeting .NET Core 2.1 Custom Packages Download the latest .NET Core SDK . Create or move your existing project to use .NET Core. Modify your <TargetFramework> tag to at least netcoreapp2.1 , or by adding the --framework netcoreapp2.1 switch when building. Install or compile the following packages: Discord.Net.Providers.WS4Net Discord.Net.Providers.UDPClient (Optional) This is only required if your bot will be utilizing voice chat. Configure your DiscordSocketClient to use these custom providers over the default ones. To do this, set the WebSocketProvider and the optional UdpSocketProvider properties on the DiscordSocketConfig that you are passing into your client. using Discord.Providers.WS4Net; using Discord.Providers.UDPClient; using Discord.WebSocket; // ... var client = new DiscordSocketClient(new DiscordSocketConfig { WebSocketProvider = WS4NetProvider.Instance, UdpSocketProvider = UDPClientProvider.Instance, });"
  },
  "guides/getting_started/first-bot.html": {
    "href": "guides/getting_started/first-bot.html",
    "title": "Start making a bot | Discord.Net Documentation",
    "keywords": "Making Your First Bot with Discord.Net One of the ways to get started with the Discord API is to write a basic ping-pong bot. This bot will respond to a simple command \"ping.\" We will expand on this to create more diverse commands later, but for now, it is a good starting point. Creating a Discord Bot Before writing your bot, it is necessary to create a bot account via the Discord Applications Portal first. Visit the Discord Applications Portal . Create a new application. Give the application a name (this will be the bot's initial username). On the left-hand side, under Settings , click Bot . Click on Add Bot . Confirm the popup. (Optional) If this bot will be public, tick Public Bot . Adding your bot to a server Bots cannot use invite links; they must be explicitly invited through the OAuth2 flow. Open your bot's application on the Discord Applications Portal . On the left-hand side, under Settings , click OAuth2 . Scroll down to OAuth2 URL Generator and under Scopes tick bot . Scroll down further to Bot Permissions and select the permissions that you wish to assign your bot with. Note This will assign the bot with a special \"managed\" role that no one else can use. The permissions can be changed later in the roles settings if you ever change your mind! Open the generated authorization URL in your browser. Select a server. Click on Authorize. Note Only servers where you have the MANAGE_SERVER permission will be present in this list. Connecting to Discord If you have not already created a project and installed Discord.Net, do that now. For more information, see Installing Discord.Net . Async Discord.Net uses .NET's Task-based Asynchronous Pattern (TAP) extensively - nearly every operation is asynchronous. It is highly recommended for these operations to be awaited in a properly established async context whenever possible. To establish an async context, we will be creating an async main method in your console application, and rewriting the static main method to invoke the new async main. public class Program { public static void Main(string[] args) => new Program().MainAsync().GetAwaiter().GetResult(); public async Task MainAsync() { } } As a result of this, your program will now start and immediately jump into an async context. This allows us to create a connection to Discord later on without having to worry about setting up the correct async implementation. Warning If your application throws any exceptions within an async context, they will be thrown all the way back up to the first non-async method; since our first non-async method is the program's Main method, this means that all unhandled exceptions will be thrown up there, which will crash your application. Discord.Net will prevent exceptions in event handlers from crashing your program, but any exceptions in your async main will cause the application to crash. Creating a logging method Before we create and configure a Discord client, we will add a method to handle Discord.Net's log events. To allow agnostic support of as many log providers as possible, we log information through a Log event with a proprietary LogMessage parameter. See the API Documentation for this event. If you are using your own logging framework, this is where you would invoke it. For the sake of simplicity, we will only be logging to the console. You may learn more about this concept in Logging Events/Data . private Task Log(LogMessage msg) { Console.WriteLine(msg.ToString()); return Task.CompletedTask; } Creating a Discord Client Finally, we can create a new connection to Discord. Since we are writing a bot, we will be using a DiscordSocketClient along with socket entities. See Terminology if you are unsure of the differences. To establish a new connection, we will create an instance of DiscordSocketClient in the new async main. You may pass in an optional @Discord.WebSocket.DiscordSocketConfig if necessary. For most users, the default will work fine. Before connecting, we should hook the client's Log event to the log handler that we had just created. Events in Discord.Net work similarly to any other events in C#. Next, you will need to \"log in to Discord\" with the LoginAsync method with the application's \"token.\" Note Pay attention to what you are copying from the developer portal! A token is not the same as the application's \"client secret.\" Important Your bot's token can be used to gain total access to your bot, so do not share this token with anyone else! You should store this token in an external source if you plan on distributing the source code for your bot. In the following example, we retrieve the token from the environment variable DiscordToken . Please note that this is not designed to be used in a production environment, as the secrets are stored in plain-text. For information on how to set an environment variable, please see instructions below, Windows: How to Create Environment Variables Shortcut in Windows Linux: How To Read and Set Environmental and Shell Variables on a Linux VPS macOS: How do I set environment variables on OS X? We may now invoke the client's StartAsync method, which will start connection/reconnection logic. It is important to note that this method will return as soon as connection logic has been started! Any methods that rely on the client's state should go in an event handler. This means that you should not directly be interacting with the client before it is fully ready. Finally, we will want to block the async main method from returning when running the application. To do this, we can await an infinite delay or any other blocking method, such as reading from the console. The following lines can now be added: private DiscordSocketClient _client; public async Task MainAsync() { _client = new DiscordSocketClient(); _client.Log += Log; // You can assign your bot token to a string, and pass that in to connect. // This however is insecure, particularly if you plan to have your code hosted in a repository. var token = \"token\"; // Some alternative options would be to keep your token in an Environment Variable or a standalone file. // var token = Environment.GetEnvironmentVariable(\"NameOfYourEnvironmentVariable\"); // var token = File.ReadAllText(\"token.txt\"); // var token = JsonConvert.DeserializeObject<AConfigurationClass>(File.ReadAllText(\"config.json\")).Token; await _client.LoginAsync(TokenType.Bot, token); await _client.StartAsync(); // Block this task until the program is closed. await Task.Delay(-1); } At this point, feel free to start your program and see your bot come online in Discord. Warning Getting a warning about A supplied token was invalid. and/or having trouble logging in? Double-check whether you have put in the correct credentials and make sure that it is not a client secret, which is different from a token. Warning Encountering a PlatformNotSupportedException when starting your bot? This means that you are targeting a platform where .NET's default WebSocket client is not supported. Refer to the installation guide for how to fix this. Note For your reference, you may view the completed program . Building a bot with commands To create commands for your bot, you may choose from a variety of command processors available. Throughout the guides, we will be using the one that Discord.Net ships with. Introduction to Command Service will guide you through how to setup a program that is ready for CommandService . For reference, view an annotated example of this structure. It is important to know that the recommended design pattern of bots should be to separate... the program (initialization and command handler) the modules (handle commands) the services (persistent storage, pure functions, data manipulation)"
  },
  "guides/emoji/emoji.html": {
    "href": "guides/emoji/emoji.html",
    "title": "Emoji | Discord.Net Documentation",
    "keywords": "Emoji in Discord.Net Before we delve into the difference between an @Discord.Emoji and an @Discord.Emote in Discord.Net, it is crucial to understand what they both look like behind the scene. When the end-users are sending or receiving an emoji or emote, they are typically in the form of :ok_hand: or :reeee: ; however, what goes under the hood is that, depending on the type of emoji, they are sent in an entirely different format. What does this all mean? It means that you should know that by reacting with a string like “:ok_hand:” will NOT automatically translate to 👌 ; rather, it will be treated as-is, like :ok_hand: , thus the server will return a 400 Bad Request . Emoji An emoji is a standard emoji that can be found anywhere else outside of Discord, which means strings like 👌 , ♥ , 👀 are all considered an emoji in Discord. However, from the introduction paragraph we have learned that we cannot simply send :ok_hand: and have Discord take care of it, but what do we need to send exactly? To send an emoji correctly, one must send the emoji in its Unicode form; this can be obtained in several different ways. (Easiest) Escape the emoji by using the escape character, \\ , in your Discord chat client; this will reveal the emoji’s pure Unicode form, which will allow you to copy-paste into your code. Look it up on Emojipedia, from which you can copy the emoji easily into your code. (Recommended) Look it up in the Emoji list from FileFormat.Info ; this will give you the .NET-compatible code that represents the emoji. This is the most recommended method because some systems or IDE sometimes do not render the Unicode emoji correctly. Emoji Declaration After obtaining the Unicode representation of the emoji, you may create the @Discord.Emoji object by passing the string into its constructor (e.g. new Emoji(\"👌\"); or new Emoji(\"\\uD83D\\uDC4C\"); ). Your method of declaring an @Discord.Emoji should look similar to this: public async Task ReactAsync(SocketUserMessage userMsg) { // equivalent to \"👌\" var emoji = new Emoji(\"\\uD83D\\uDC4C\"); await userMsg.AddReactionAsync(emoji); } Emote The meat of the debate is here; what is an emote and how does it differ from an emoji? An emote refers to a custom emoji created on Discord. The underlying structure of an emote also differs drastically; an emote looks sort-of like a mention on Discord. It consists of two main elements as illustrated below: As you can see, emote uses a completely different format. To obtain the raw string as shown above for your emote, you would need to escape the emote using the escape character \\ in chat somewhere. Emote Declaration After obtaining the raw emote string, you would need to use @Discord.Emote.Parse* or @Discord.Emote.TryParse* to create a valid emote object. Your method of declaring an @Discord.Emote should look similar to this: public async Task ReactWithEmoteAsync(SocketUserMessage userMsg, string escapedEmote) { if (Emote.TryParse(escapedEmote, out var emote)) { await userMsg.AddReactionAsync(emote); } } Tip For WebSocket users, you may also consider fetching the Emote via the @Discord.WebSocket.SocketGuild.Emotes collection. private readonly DiscordSocketClient _client; public async Task ReactAsync(SocketUserMessage userMsg, string emoteName) { var emote = _client.Guilds .SelectMany(x => x.Emotes) .FirstOrDefault(x => x.Name.IndexOf( emoteName, StringComparison.OrdinalIgnoreCase) != -1); if (emote == null) return; await userMsg.AddReactionAsync(emote); } Tip On Discord, any user with Discord Nitro subscription may use custom emotes from any guilds they are currently in. This is also true for any standard bot accounts; this does not require the bot owner to have a Nitro subscription. Additional Information To learn more about emote and emojis and how they could be used, see the documentation of @Discord.IEmote."
  },
  "guides/concepts/logging.html": {
    "href": "guides/concepts/logging.html",
    "title": "Logging Events/Data | Discord.Net Documentation",
    "keywords": "Logging in Discord.Net Discord.Net's clients provide a log event that all messages will be dispatched over. For more information about events in Discord.Net, see the Events section. Warning Due to the nature of Discord.Net's event system, all log event handlers will be executed synchronously on the gateway thread. If your log output will be dumped to a Web API (e.g., Sentry), you are advised to wrap your output in a Task.Run so the gateway thread does not become blocked while waiting for logging data to be written. Usage in Client(s) To receive log events, simply hook the Discord client's @Discord.Rest.BaseDiscordClient.Log to a Task with a single parameter of type LogMessage . It is recommended that you use an established function instead of a lambda for handling logs, because most addons accept a reference to a logging function to write their own messages. Usage in Commands Discord.Net's CommandService also provides a @Discord.Commands.CommandService.Log event, identical in signature to other log events. Data logged through this event is typically coupled with a CommandException , where information about the command's context and error can be found and handled. Sample using Discord; using Discord.WebSocket; public class LoggingService { public LoggingService(DiscordSocketClient client, CommandService command) { client.Log += LogAsync; command.Log += LogAsync; } private Task LogAsync(LogMessage message) { if (message.Exception is CommandException cmdException) { Console.WriteLine($\"[Command/{message.Severity}] {cmdException.Command.Aliases.First()}\" + $\" failed to execute in {cmdException.Context.Channel}.\"); Console.WriteLine(cmdException); } else Console.WriteLine($\"[General/{message.Severity}] {message}\"); return Task.CompletedTask; } }"
  },
  "guides/concepts/events.html": {
    "href": "guides/concepts/events.html",
    "title": "Working with Events | Discord.Net Documentation",
    "keywords": "Events in Discord.Net Events in Discord.Net are consumed in a similar manner to the standard convention, with the exception that every event must be of the type Task and instead of using EventArgs , the event's parameters are passed directly into the handler. This allows for events to be handled in an async context directly instead of relying on async void . Usage To receive data from an event, hook into it using C#'s delegate event pattern. You may either opt to hook an event to an anonymous function (lambda) or a named function. Safety All events are designed to be thread-safe; events are executed synchronously off the gateway task in the same context as the gateway task. As a side effect, this makes it possible to deadlock the gateway task and kill a connection. As a general rule of thumb, any task that takes longer than three seconds should not be awaited directly in the context of an event, but should be wrapped in a Task.Run or offloaded to another task. This also means that you should not await a task that requests data from Discord's gateway in the same context of an event. Since the gateway will wait on all invoked event handlers to finish before processing any additional data from the gateway, this will create a deadlock that will be impossible to recover from. Exceptions in commands will be swallowed by the gateway and logged out through the client's log method. Common Patterns As you may know, events in Discord.Net are only given a signature of Func<T1, ..., Task> . There is no room for predefined argument names, so you must either consult IntelliSense, or view the API documentation directly. That being said, there are a variety of common patterns that allow you to infer what the parameters in an event mean. Entity, Entity An event handler with a signature of Func<Entity, Entity, Task> typically means that the first object will be a clone of the entity before a change was made, and the latter object will be an attached model of the entity after the change was made. This pattern is typically only found on EntityUpdated events. Cacheable An event handler with a signature of Func<Cacheable, Entity, Task> means that the before state of the entity was not provided by the API, so it can either be pulled from the client's cache or downloaded from the API. See the documentation for Cacheable for more information on this object. Note Many events relating to a Message entity (i.e., MessageUpdated and ReactionAdded ) rely on the client's message cache, which is not enabled by default. Set the MessageCacheSize flag in @Discord.WebSocket.DiscordSocketConfig to enable it. Sample using Discord; using Discord.WebSocket; public class Program { private DiscordSocketClient _client; static void Main(string[] args) => new Program().MainAsync().GetAwaiter().GetResult(); public async Task MainAsync() { // When working with events that have Cacheable<IMessage, ulong> parameters, // you must enable the message cache in your config settings if you plan to // use the cached message entity. var _config = new DiscordSocketConfig { MessageCacheSize = 100 }; _client = new DiscordSocketClient(_config); await _client.LoginAsync(TokenType.Bot, Environment.GetEnvironmentVariable(\"DiscordToken\")); await _client.StartAsync(); _client.MessageUpdated += MessageUpdated; _client.Ready += () => { Console.WriteLine(\"Bot is connected!\"); return Task.CompletedTask; } await Task.Delay(-1); } private async Task MessageUpdated(Cacheable<IMessage, ulong> before, SocketMessage after, ISocketMessageChannel channel) { // If the message was not in the cache, downloading it will result in getting a copy of `after`. var message = await before.GetOrDownloadAsync(); Console.WriteLine($\"{message} -> {after}\"); } }"
  },
  "guides/concepts/entities.html": {
    "href": "guides/concepts/entities.html",
    "title": "Entities | Discord.Net Documentation",
    "keywords": "Entities in Discord.Net Note This article is written with the Socket variants of entities in mind, not the general interfaces or Rest entities. Discord.Net provides a versatile entity system for navigating the Discord API. Inheritance Due to the nature of the Discord API, some entities are designed with multiple variants; for example, SocketUser and SocketGuildUser . All models will contain the most detailed version of an entity possible, even if the type is less detailed. For example, in the case of the MessageReceived event, a SocketMessage is passed in with a channel property of type SocketMessageChannel . All messages come from channels capable of messaging, so this is the only variant of a channel that can cover every single case. But that doesn't mean a message can't come from a SocketTextChannel , which is a message channel in a guild. To retrieve information about a guild from a message entity, you will need to cast its channel object to a SocketTextChannel . You can find out various types of entities in the @FAQ.Misc.Glossary page. Navigation All socket entities have navigation properties on them, which allow you to easily navigate to an entity's parent or children. As explained above, you will sometimes need to cast to a more detailed version of an entity to navigate to its parent. Accessing Entities The most basic forms of entities, SocketGuild , SocketUser , and SocketChannel can be pulled from the DiscordSocketClient's global cache, and can be retrieved using the respective GetXXX method on DiscordSocketClient. Tip It is vital that you use the proper IDs for an entity when using a GetXXX method. It is recommended that you enable Discord's developer mode to allow easy access to entity IDs, found in Settings > Appearance > Advanced. Read more about it in the FAQ page. More detailed versions of entities can be pulled from the basic entities, e.g., SocketGuild.GetUser , which returns a SocketGuildUser , or SocketGuild.GetChannel , which returns a SocketGuildChannel . Again, you may need to cast these objects to get a variant of the type that you need. Sample public string GetChannelTopic(ulong id) { var channel = client.GetChannel(81384956881809408) as SocketTextChannel; return channel?.Topic; } public SocketGuildUser GetGuildOwner(SocketChannel channel) { var guild = (channel as SocketGuildChannel)?.Guild; return guild?.Owner; }"
  },
  "guides/concepts/connections.html": {
    "href": "guides/concepts/connections.html",
    "title": "Managing Connections | Discord.Net Documentation",
    "keywords": "Managing Connections with Discord.Net In Discord.Net, once a client has been started, it will automatically maintain a connection to Discord's gateway until it is manually stopped. Usage To start a connection, invoke the StartAsync method on a client that supports a WebSocket connection; to end a connection, invoke the StopAsync method, which gracefully closes any open WebSocket or UdpSocket connections. Since the Start/Stop methods only signal to an underlying connection manager that a connection needs to be started, they return before a connection is made. As a result, you need to hook into one of the connection-state based events to have an accurate representation of when a client is ready for use. All clients provide a Connected and Disconnected event, which is raised respectively when a connection opens or closes. In the case of the DiscordSocketClient , this does not mean that the client is ready to be used. A separate event, Ready , is provided on DiscordSocketClient , which is raised only when the client has finished guild stream or guild sync and has a completed guild cache. Reconnection Tip Avoid running long-running code on the gateway! If you deadlock the gateway (as explained in events ), the connection manager will NOT be able to recover and reconnect. Assuming the client disconnected because of a fault on Discord's end, and not a deadlock on your end, we will always attempt to reconnect and resume a connection. Don't worry about trying to maintain your own connections, the connection manager is designed to be bulletproof and never fail - if your client does not manage to reconnect, you have found a bug!"
  },
  "guides/commands/typereaders.html": {
    "href": "guides/commands/typereaders.html",
    "title": "Type Readers | Discord.Net Documentation",
    "keywords": "Type Readers Type Readers allow you to parse different types of arguments in your commands. By default, the following Types are supported arguments: bool char sbyte / byte ushort / short uint / int ulong / long float , double , decimal string enum DateTime / DateTimeOffset / TimeSpan Any nullable value-type (e.g. int? , bool? ) Any implementation of IChannel / IMessage / IUser / IRole Creating a Type Reader To create a TypeReader , create a new class that imports @Discord and @Discord.Commands and ensure the class inherits from @Discord.Commands.TypeReader. Next, satisfy the TypeReader class by overriding the ReadAsync method. Inside this Task, add whatever logic you need to parse the input string. If you are able to successfully parse the input, return TypeReaderResult.FromSuccess with the parsed input, otherwise return TypeReaderResult.FromError and include an error message if necessary. Note Visual Studio can help you implement missing members from the abstract class by using the \"Implement Abstract Class\" IntelliSense hint. Example - Creating a Type Reader // Please note that the library already supports type reading // primitive types such as bool. This example is merely used // to demonstrate how one could write a simple TypeReader. using Discord; using Discord.Commands; public class BooleanTypeReader : TypeReader { public override Task<TypeReaderResult> ReadAsync(ICommandContext context, string input, IServiceProvider services) { bool result; if (bool.TryParse(input, out result)) return Task.FromResult(TypeReaderResult.FromSuccess(result)); return Task.FromResult(TypeReaderResult.FromError(CommandError.ParseFailed, \"Input could not be parsed as a boolean.\")); } } Registering a Type Reader TypeReaders are not automatically discovered by the Command Service and must be explicitly added. To register a TypeReader, invoke CommandService.AddTypeReader . Important TypeReaders must be added prior to module discovery, otherwise your TypeReaders may not work! Example - Adding a Type Reader public class CommandHandler { private readonly CommandService _commands; private readonly DiscordSocketClient _client; private readonly IServiceProvider _services; public CommandHandler(CommandService commands, DiscordSocketClient client, IServiceProvider services) { _commands = commands; _client = client; _services = services; } public async Task SetupAsync() { _client.MessageReceived += CommandHandleAsync; // Add BooleanTypeReader to type read for the type \"bool\" _commands.AddTypeReader(typeof(bool), new BooleanTypeReader()); // Then register the modules await _commands.AddModulesAsync(Assembly.GetEntryAssembly(), _services); } public async Task CommandHandleAsync(SocketMessage msg) { // ... } }"
  },
  "guides/commands/preconditions.html": {
    "href": "guides/commands/preconditions.html",
    "title": "Preconditions | Discord.Net Documentation",
    "keywords": "Preconditions Preconditions serve as a permissions system for your Commands. Keep in mind, however, that they are not limited to just permissions and can be as complex as you want them to be. There are two types of Preconditions you can use: PreconditionAttribute can be applied to Modules, Groups, or Commands. ParameterPreconditionAttribute can be applied to Parameters. You may visit their respective API documentation to find out more. Bundled Preconditions @Discord.Commands ships with several bundled Preconditions for you to use. @Discord.Commands.RequireContextAttribute @Discord.Commands.RequireOwnerAttribute @Discord.Commands.RequireBotPermissionAttribute @Discord.Commands.RequireUserPermissionAttribute @Discord.Commands.RequireNsfwAttribute Using Preconditions To use a precondition, simply apply any valid precondition candidate to a command method signature as an attribute. Example - Using a Precondition [RequireOwner] [Command(\"echo\")] public Task EchoAsync(string input) => ReplyAsync(input); ORing Preconditions When writing commands, you may want to allow some of them to be executed when only some of the precondition checks are passed. This is where the Group property of a precondition attribute comes in handy. By assigning two or more preconditions to a group, the command system will allow the command to be executed when one of the precondition passes. Example - ORing Preconditions // The following example only requires the user to either have the // Administrator permission in this guild or own the bot application. [RequireUserPermission(GuildPermission.Administrator, Group = \"Permission\")] [RequireOwner(Group = \"Permission\")] public class AdminModule : ModuleBase<SocketCommandContext> { [Command(\"ban\")] public Task BanAsync(IUser user) => Context.Guild.AddBanAsync(user); } Custom Preconditions To write your own Precondition, create a new class that inherits from either PreconditionAttribute or ParameterPreconditionAttribute depending on your use. In order for your Precondition to function, you will need to override the CheckPermissionsAsync method. If the context meets the required parameters, return PreconditionResult.FromSuccess , otherwise return PreconditionResult.FromError and include an error message if necessary. Note Visual Studio can help you implement missing members from the abstract class by using the \"Implement Abstract Class\" IntelliSense hint. Example - Creating a Custom Precondition using System; using System.Threading.Tasks; using Discord.Commands; using Discord.WebSocket; // Inherit from PreconditionAttribute public class RequireRoleAttribute : PreconditionAttribute { // Create a field to store the specified name private readonly string _name; // Create a constructor so the name can be specified public RequireRoleAttribute(string name) => _name = name; // Override the CheckPermissions method public override Task<PreconditionResult> CheckPermissionsAsync(ICommandContext context, CommandInfo command, IServiceProvider services) { // Check if this user is a Guild User, which is the only context where roles exist if (context.User is SocketGuildUser gUser) { // If this command was executed by a user with the appropriate role, return a success if (gUser.Roles.Any(r => r.Name == _name)) // Since no async work is done, the result has to be wrapped with `Task.FromResult` to avoid compiler errors return Task.FromResult(PreconditionResult.FromSuccess()); // Since it wasn't, fail else return Task.FromResult(PreconditionResult.FromError($\"You must have a role named {_name} to run this command.\")); } else return Task.FromResult(PreconditionResult.FromError(\"You must be in a guild to run this command.\")); } }"
  },
  "guides/commands/post-execution.html": {
    "href": "guides/commands/post-execution.html",
    "title": "Post-command Execution Handling | Discord.Net Documentation",
    "keywords": "Post-execution Handling for Commands When developing commands, you may want to consider building a post-execution handling system so you can have finer control over commands. Discord.Net offers several post-execution workflows for you to work with. If you recall, in the Command Guide , we have shown the following example for executing and handling commands, public class CommandHandler { private readonly DiscordSocketClient _client; private readonly CommandService _commands; // Retrieve client and CommandService instance via ctor public CommandHandler(DiscordSocketClient client, CommandService commands) { _commands = commands; _client = client; } public async Task InstallCommandsAsync() { // Hook the MessageReceived event into our command handler _client.MessageReceived += HandleCommandAsync; // Here we discover all of the command modules in the entry // assembly and load them. Starting from Discord.NET 2.0, a // service provider is required to be passed into the // module registration method to inject the // required dependencies. // // If you do not use Dependency Injection, pass null. // See Dependency Injection guide for more information. await _commands.AddModulesAsync(assembly: Assembly.GetEntryAssembly(), services: null); } private async Task HandleCommandAsync(SocketMessage messageParam) { // Don't process the command if it was a system message var message = messageParam as SocketUserMessage; if (message == null) return; // Create a number to track where the prefix ends and the command begins int argPos = 0; // Determine if the message is a command based on the prefix and make sure no bots trigger commands if (!(message.HasCharPrefix('!', ref argPos) || message.HasMentionPrefix(_client.CurrentUser, ref argPos)) || message.Author.IsBot) return; // Create a WebSocket-based command context based on the message var context = new SocketCommandContext(_client, message); // Execute the command with the command context we just // created, along with the service provider for precondition checks. await _commands.ExecuteAsync( context: context, argPos: argPos, services: null); } } You may notice that after we perform ExecuteAsync , we store the result and print it to the chat, essentially creating the most fundamental form of a post-execution handler. With this in mind, we could start doing things like the following, // Bad code!!! var result = await _commands.ExecuteAsync(context, argPos, _services); if (result.CommandError != null) switch(result.CommandError) { case CommandError.BadArgCount: await context.Channel.SendMessageAsync( \"Parameter count does not match any command's.\"); break; default: await context.Channel.SendMessageAsync( $\"An error has occurred {result.ErrorReason}\"); break; } However, this may not always be preferred, because you are creating your post-execution logic with the essential command handler. This design could lead to messy code and could potentially be a violation of the SRP (Single Responsibility Principle). Another major issue is if your command is marked with RunMode.Async , ExecuteAsync will always return a successful ExecuteResult instead of the actual result. You can learn more about the impact in General Questions about Commands . CommandExecuted Event Enter CommandExecuted , an event that was introduced in Discord.Net 2.0. This event is raised whenever a command is executed regardless of its execution status. This means this event can be used to streamline your post-execution design, is not prone to RunMode.Async 's ExecuteAsync drawbacks. Thus, we can begin working on code such as: public async Task SetupAsync() { await _command.AddModulesAsync(Assembly.GetEntryAssembly(), _services); // Hook the execution event _command.CommandExecuted += OnCommandExecutedAsync; // Hook the command handler _client.MessageReceived += HandleCommandAsync; } public async Task OnCommandExecutedAsync(Optional<CommandInfo> command, ICommandContext context, IResult result) { // We have access to the information of the command executed, // the context of the command, and the result returned from the // execution in this event. // We can tell the user what went wrong if (!string.IsNullOrEmpty(result?.ErrorReason)) { await context.Channel.SendMessageAsync(result.ErrorReason); } // ...or even log the result (the method used should fit into // your existing log handler) var commandName = command.IsSpecified ? command.Value.Name : \"A command\"; await _log.LogAsync(new LogMessage(LogSeverity.Info, \"CommandExecution\", $\"{commandName} was executed at {DateTime.UtcNow}.\")); } public async Task HandleCommandAsync(SocketMessage msg) { var message = messageParam as SocketUserMessage; if (message == null) return; int argPos = 0; if (!(message.HasCharPrefix('!', ref argPos) || message.HasMentionPrefix(_client.CurrentUser, ref argPos)) || message.Author.IsBot) return; var context = new SocketCommandContext(_client, message); await _commands.ExecuteAsync(context, argPos, _services); } So now we have a streamlined post-execution pipeline, great! What's next? We can take this further by using RuntimeResult . RuntimeResult RuntimeResult was initially introduced in 1.0 to allow developers to centralize their command result logic. In other words, it is a result type that is designed to be returned when the command has finished its execution. However, it wasn't widely adopted due to the aforementioned ExecuteAsync drawback. Since we now have access to a proper result-handler via the CommandExecuted event, we can start making use of this class. The best way to make use of it is to create your version of RuntimeResult . You can achieve this by inheriting the RuntimeResult class. The following creates a bare-minimum required for a sub-class of RuntimeResult , public class MyCustomResult : RuntimeResult { public MyCustomResult(CommandError? error, string reason) : base(error, reason) { } } The sky is the limit from here. You can add any additional information you would like regarding the execution result. For example, you may want to add your result type or other helpful information regarding the execution, or something simple like static methods to help you create return types easily. public class MyCustomResult : RuntimeResult { public MyCustomResult(CommandError? error, string reason) : base(error, reason) { } public static MyCustomResult FromError(string reason) => new MyCustomResult(CommandError.Unsuccessful, reason); public static MyCustomResult FromSuccess(string reason = null) => new MyCustomResult(null, reason); } After you're done creating your RuntimeResult , you can implement it in your command by marking the command return type to Task<RuntimeResult> . Note You must mark the return type as Task<RuntimeResult> instead of Task<MyCustomResult> . Only the former will be picked up when building the module. Here's an example of a command that utilizes such logic: public class MyModule : ModuleBase<SocketCommandContext> { [Command(\"eat\")] public async Task<RuntimeResult> ChooseAsync(string food) { if (food == \"salad\") return MyCustomResult.FromError(\"No, I don't want that!\"); return MyCustomResult.FromSuccess($\"Give me the {food}!\"). } } And now we can check for it in our CommandExecuted handler: public async Task OnCommandExecutedAsync(Optional<CommandInfo> command, ICommandContext context, IResult result) { switch(result) { case MyCustomResult customResult: // do something extra with it break; default: if (!string.IsNullOrEmpty(result.ErrorReason)) await context.Channel.SendMessageAsync(result.ErrorReason); break; } } CommandService.Log Event We have so far covered the handling of various result types, but we have not talked about what to do if the command enters a catastrophic failure (i.e., exceptions). To resolve this, we can make use of the CommandService.Log event. All exceptions thrown during a command execution are caught and sent to the Log event under the LogMessage.Exception property as a CommandException type. The CommandException class allows us to access the exception thrown, as well as the context of the command. public async Task LogAsync(LogMessage logMessage) { if (logMessage.Exception is CommandException cmdException) { // We can tell the user that something unexpected has happened await cmdException.Context.Channel.SendMessageAsync(\"Something went catastrophically wrong!\"); // We can also log this incident Console.WriteLine($\"{cmdException.Context.User} failed to execute '{cmdException.Command.Name}' in {cmdException.Context.Channel}.\"); Console.WriteLine(cmdException.ToString()); } }"
  },
  "guides/commands/intro.html": {
    "href": "guides/commands/intro.html",
    "title": "Introduction to Command Service | Discord.Net Documentation",
    "keywords": "The Command Service Discord.Commands provides an attribute-based command parser. Get Started To use commands, you must create a Command Service and a command handler. Included below is a barebone command handler. You can extend your command handler as much as you like; however, the below is the bare minimum. Note The CommandService will optionally accept a CommandServiceConfig , which does set a few default values for you. It is recommended to look over the properties in CommandServiceConfig and their default values. public class CommandHandler { private readonly DiscordSocketClient _client; private readonly CommandService _commands; // Retrieve client and CommandService instance via ctor public CommandHandler(DiscordSocketClient client, CommandService commands) { _commands = commands; _client = client; } public async Task InstallCommandsAsync() { // Hook the MessageReceived event into our command handler _client.MessageReceived += HandleCommandAsync; // Here we discover all of the command modules in the entry // assembly and load them. Starting from Discord.NET 2.0, a // service provider is required to be passed into the // module registration method to inject the // required dependencies. // // If you do not use Dependency Injection, pass null. // See Dependency Injection guide for more information. await _commands.AddModulesAsync(assembly: Assembly.GetEntryAssembly(), services: null); } private async Task HandleCommandAsync(SocketMessage messageParam) { // Don't process the command if it was a system message var message = messageParam as SocketUserMessage; if (message == null) return; // Create a number to track where the prefix ends and the command begins int argPos = 0; // Determine if the message is a command based on the prefix and make sure no bots trigger commands if (!(message.HasCharPrefix('!', ref argPos) || message.HasMentionPrefix(_client.CurrentUser, ref argPos)) || message.Author.IsBot) return; // Create a WebSocket-based command context based on the message var context = new SocketCommandContext(_client, message); // Execute the command with the command context we just // created, along with the service provider for precondition checks. await _commands.ExecuteAsync( context: context, argPos: argPos, services: null); } } With Attributes Starting from 1.0, commands can be defined ahead of time with attributes, or at runtime with builders. For most bots, ahead-of-time commands should be all you need, and this is the recommended method of defining commands. Modules The first step to creating commands is to create a module . A module is an organizational pattern that allows you to write your commands in different classes and have them automatically loaded. Discord.Net's implementation of \"modules\" is influenced heavily by the ASP.NET Core's Controller pattern. This means that the lifetime of a module instance is only as long as the command is being invoked. Before we create a module, it is crucial for you to remember that in order to create a module and have it automatically discovered, your module must: Be public Inherit ModuleBase By now, your module should look like this: using Discord.Commands; // Keep in mind your module **must** be public and inherit ModuleBase. // If it isn't, it will not be discovered by AddModulesAsync! public class InfoModule : ModuleBase<SocketCommandContext> { } Note ModuleBase is an abstract class, meaning that you may extend it or override it as you see fit. Your module may inherit from any extension of ModuleBase. Adding/Creating Commands Warning Avoid using long-running code in your modules wherever possible. You should not be implementing very much logic into your modules, instead, outsource to a service for that. If you are unfamiliar with Inversion of Control, it is recommended to read the MSDN article on IoC and Dependency Injection . The next step to creating commands is actually creating the commands. For a command to be valid, it must have a return type of Task or Task<RuntimeResult> . Typically, you might want to mark this method as async , although it is not required. Then, flag your command with the CommandAttribute . Note that you must specify a name for this command, except for when it is part of a Module Group . Command Parameters Adding parameters to a command is done by adding parameters to the parent Task . For example: To take an integer as an argument from the user, add int num . To take a user as an argument from the user, add IUser user . ...etc. Starting from 1.0, a command can accept nearly any type of argument; a full list of types that are parsed by default can be found in Type Readers . Optional Parameters Parameters, by default, are always required. To make a parameter optional, give it a default value (i.e., int num = 0 ). Parameters with Spaces To accept a comma-separated list, set the parameter to params Type[] . Should a parameter include spaces, the parameter must be wrapped in quotes. For example, for a command with a parameter string food , you would execute it with !favoritefood \"Key Lime Pie\" . If you would like a parameter to parse until the end of a command, flag the parameter with the RemainderAttribute . This will allow a user to invoke a command without wrapping a parameter in quotes. Command Overloads You may add overloads to your commands, and the command parser will automatically pick up on it. If, for whatever reason, you have two commands which are ambiguous to each other, you may use the @Discord.Commands.PriorityAttribute to specify which should be tested before the other. The Priority attributes are sorted in ascending order; the higher priority will be called first. Command Context Every command can access the execution context through the Context property on ModuleBase . ICommandContext allows you to access the message, channel, guild, user, and the underlying Discord client that the command was invoked from. Different types of Context may be specified using the generic variant of ModuleBase . When using a SocketCommandContext , for example, the properties on this context will already be Socket entities, so you will not need to cast them. To reply to messages, you may also invoke ReplyAsync , instead of accessing the channel through the Context and sending a message. Warning Contexts should NOT be mixed! You cannot have one module that uses CommandContext and another that uses SocketCommandContext . Tip At this point, your module should look comparable to this example: // Create a module with no prefix public class InfoModule : ModuleBase<SocketCommandContext> { // ~say hello world -> hello world [Command(\"say\")] [Summary(\"Echoes a message.\")] public Task SayAsync([Remainder] [Summary(\"The text to echo\")] string echo) => ReplyAsync(echo); // ReplyAsync is a method on ModuleBase } // Create a module with the 'sample' prefix [Group(\"sample\")] public class SampleModule : ModuleBase<SocketCommandContext> { // ~sample square 20 -> 400 [Command(\"square\")] [Summary(\"Squares a number.\")] public async Task SquareAsync( [Summary(\"The number to square.\")] int num) { // We can also access the channel from the Command Context. await Context.Channel.SendMessageAsync($\"{num}^2 = {Math.Pow(num, 2)}\"); } // ~sample userinfo --> foxbot#0282 // ~sample userinfo @Khionu --> Khionu#8708 // ~sample userinfo Khionu#8708 --> Khionu#8708 // ~sample userinfo Khionu --> Khionu#8708 // ~sample userinfo 96642168176807936 --> Khionu#8708 // ~sample whois 96642168176807936 --> Khionu#8708 [Command(\"userinfo\")] [Summary (\"Returns info about the current user, or the user parameter, if one passed.\")] [Alias(\"user\", \"whois\")] public async Task UserInfoAsync( [Summary(\"The (optional) user to get info from\")] SocketUser user = null) { var userInfo = user ?? Context.Client.CurrentUser; await ReplyAsync($\"{userInfo.Username}#{userInfo.Discriminator}\"); } } Loading Modules Automatically The Command Service can automatically discover all classes in an Assembly that inherit ModuleBase and load them. Invoke CommandService.AddModulesAsync to discover modules and install them. To opt a module out of auto-loading, flag it with DontAutoLoadAttribute . Loading Modules Manually To manually load a module, invoke CommandService.AddModuleAsync by passing in the generic type of your module and optionally, a service provider. Module Constructors Modules are constructed using Dependency Injection . Any parameters that are placed in the Module's constructor must be injected into an IServiceProvider first. Tip Alternatively, you may accept an IServiceProvider as an argument and extract services yourself, although this is discouraged. Module Properties Modules with public settable properties will have the dependencies injected after the construction of the module. See Dependency Injection to learn more. Module Groups Module Groups allow you to create a module where commands are prefixed. To create a group, flag a module with the @Discord.Commands.GroupAttribute. Module Groups also allow you to create nameless Commands , where the CommandAttribute is configured with no name. In this case, the command will inherit the name of the group it belongs to. Submodules Submodules are \"modules\" that reside within another one. Typically, submodules are used to create nested groups (although not required to create nested groups). [Group(\"admin\")] public class AdminModule : ModuleBase<SocketCommandContext> { [Group(\"clean\")] public class CleanModule : ModuleBase<SocketCommandContext> { // ~admin clean [Command] public async Task DefaultCleanAsync() { // ... } // ~admin clean messages 15 [Command(\"messages\")] public async Task CleanAsync(int count) { // ... } } // ~admin ban foxbot#0282 [Command(\"ban\")] public Task BanAsync(IGuildUser user) => Context.Guild.AddBanAsync(user); }"
  },
  "guides/commands/dependency-injection.html": {
    "href": "guides/commands/dependency-injection.html",
    "title": "Dependency Injection | Discord.Net Documentation",
    "keywords": "Dependency Injection The Command Service is bundled with a very barebone Dependency Injection service for your convenience. It is recommended that you use DI when writing your modules. Setup Create a ServiceCollection . Add the dependencies to the service collection that you wish to use in the modules. Build the service collection into a service provider. Pass the service collection into @Discord.Commands.CommandService.AddModulesAsync* / @Discord.Commands.CommandService.AddModuleAsync* , @Discord.Commands.CommandService.ExecuteAsync* . Example - Setting up Injection public class Initialize { private readonly CommandService _commands; private readonly DiscordSocketClient _client; // Ask if there are existing CommandService and DiscordSocketClient // instance. If there are, we retrieve them and add them to the // DI container; if not, we create our own. public Initialize(CommandService commands = null, DiscordSocketClient client = null) { _commands = commands ?? new CommandService(); _client = client ?? new DiscordSocketClient(); } public IServiceProvider BuildServiceProvider() => new ServiceCollection() .AddSingleton(_client) .AddSingleton(_commands) // You can pass in an instance of the desired type .AddSingleton(new NotificationService()) // ...or by using the generic method. // // The benefit of using the generic method is that // ASP.NET DI will attempt to inject the required // dependencies that are specified under the constructor // for us. .AddSingleton<DatabaseService>() .AddSingleton<CommandHandler>() .BuildServiceProvider(); } public class CommandHandler { private readonly DiscordSocketClient _client; private readonly CommandService _commands; private readonly IServiceProvider _services; public CommandHandler(IServiceProvider services, CommandService commands, DiscordSocketClient client) { _commands = commands; _services = services; _client = client; } public async Task InitializeAsync() { // Pass the service provider to the second parameter of // AddModulesAsync to inject dependencies to all modules // that may require them. await _commands.AddModulesAsync( assembly: Assembly.GetEntryAssembly(), services: _services); _client.MessageReceived += HandleCommandAsync; } public async Task HandleCommandAsync(SocketMessage msg) { // ... // Pass the service provider to the ExecuteAsync method for // precondition checks. await _commands.ExecuteAsync( context: context, argPos: argPos, services: _services); // ... } } Usage in Modules In the constructor of your module, any parameters will be filled in by the IServiceProvider that you've passed. Any publicly settable properties will also be filled in the same manner. Note Annotating a property with a DontInjectAttribute attribute will prevent the property from being injected. Note If you accept CommandService or IServiceProvider as a parameter in your constructor or as an injectable property, these entries will be filled by the CommandService that the module is loaded from and the IServiceProvider that is passed into it respectively. Example - Injection in Modules // After setting up dependency injection, modules will need to request // the dependencies to let the library know to pass // them along during execution. // Dependency can be injected in two ways with Discord.Net. // You may inject any required dependencies via... // the module constructor // -or- // public settable properties // Injection via constructor public class DatabaseModule : ModuleBase<SocketCommandContext> { private readonly DatabaseService _database; public DatabaseModule(DatabaseService database) { _database = database; } [Command(\"read\")] public async Task ReadFromDbAsync() { await ReplyAsync(_database.GetData()); } } // Injection via public settable properties public class DatabaseModule : ModuleBase<SocketCommandContext> { public DatabaseService DbService { get; set; } [Command(\"read\")] public async Task ReadFromDbAsync() { await ReplyAsync(DbService.GetData()); } } // Sometimes injecting dependencies automatically with the provided // methods in the prior example may not be desired. // You may explicitly tell Discord.Net to **not** inject the properties // by either... // restricting the access modifier // -or- // applying DontInjectAttribute to the property // Restricting the access modifier of the property public class ImageModule : ModuleBase<SocketCommandContext> { public ImageService ImageService { get; } public ImageModule() { ImageService = new ImageService(); } } // Applying DontInjectAttribute public class ImageModule : ModuleBase<SocketCommandContext> { [DontInject] public ImageService ImageService { get; set; } public ImageModule() { ImageService = new ImageService(); } }"
  }
}